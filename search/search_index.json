{
    "docs": [
        {
            "location": "/", 
            "text": "Trabajando con teselas vectoriales\n\n\nBienvenidos al taller de teselas vectoriales. Este manual est\u00e1 publicado aqu\u00ed:\n\n\nhttps://geoinquiets.github.io/taller-vt/\n\n\nEsenciales para moverse por OSGeo Live\n\n\n\n\nUsuario: \"user\"\n\n\nPassword: \"user\"\n\n\nAlt + F2\n Para lanzar un programa de forma r\u00e1pida\n\n\nShift + Ctrl + V\n para pegar un texto del portapapeles en el terminal\n\n\n\n\nDescarga de los materiales para el taller\n\n\n1\n2\n3\n4\n5\ncd\n Desktop\nwget https://geoinquiets.github.io/taller-vt/downloads/taller-vt.zip\nunzip taller-vt.zip\n\ncd\n taller-vt\nll\n\n\n\n\n\n\nAs\u00ed pues, la ruta \n~/Desktop/taller-vt\n ser\u00e1 nuestro directorio base, donde iremos creando los recursos necesarios.\nDe momento tenemos los subdirectorios:\n\n\n\n\ndatos\n\n\nmaputnik\n\n\n\n\nComprobaci\u00f3n del software preinstalado\n\n\nEn el aula de la pr\u00e1ctica se ha preinstalado una serie de software necesario para el taller.\nEn caso de que falte alguno, se pueden consultar las instrucciones de instalaci\u00f3n en el siguiente apartado.\n\n\nComandos de comprobaci\u00f3n: \n\n\n\n\nAlt + F2\n =\n \"terminator\" deber\u00eda abrir un terminal.\n\n\ngoogle-chrome http://tileserver.fonts.cat/styles/dark-matter/style.json\n deber\u00eda abrir Chrome y mostrar un JSON formateado y coloreado.\n\n\ngoogle-chrome http://tileserver.fonts.cat/styles/dark-matter-3d/?vector#16.09/41.3861/2.19226/-47.2/60\n deber\u00eda mostrar un mapa de Barcelona con edificios en 3D, y moverse con soltura.\n\n\nnode -v\n Deber\u00eda ser 6.x.x (NO mayor que 6, si aparece 8.x.x o 10.x.x, hay que cambiar de versi\u00f3n)\n\n\nnpm -v\n\n\ncode -v\n\n\ntippecanoe -v\n\n\n\n\nInstalaci\u00f3n de requisitos de software\n\n\nEl software de base para el taller ya est\u00e1 instalado en los ordenadores del aula, pero indicamos aqu\u00ed c\u00f3mo instalarlo\ntomando como base OSGeo Live 11 (tambi\u00e9n valdr\u00e1 para Ubuntu 16.04, en el que adem\u00e1s deber\u00eda instalarse PostGIS).\n\n\n\n\nGoogle Chrome\n\n\nLa extensi\u00f3n \njson-viewer\n en Chrome\n\n\nMicrosoft Visual Studio Code\n\n\nTerminator:\n    \n1\nsudo apt install terminator\n\n\n\n\n\n\n\nnode6 y npm (sobre nvm):\n\n\nPrimero, instalar nvm:\n\n\n1\n  curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh \n|\n bash\n\n\n\n\n\n\nCerrar y reabrir el terminal.\nLuego, instalar node 6 y npm:\n\n\n1\n2\n3\n4\n5\n  nvm install 6\n  npm install -g npm\n  # comprobar versiones\n  node -v # Deber\u00eda ser 6.x.x\n  npm -v # Deber\u00eda ser 6.x.x o mayor\n\n\n\n\n\n\n\n\n\n\ntippecanoe:\n\n\nInstalar dependencias (librer\u00edas sqlite3 y zlib):\n\n\n1\nsudo apt install build-essential libsqlite3-dev zlib1g-dev\n\n\n\n\n\n\nBajarse el c\u00f3digo fuente:\n\n\n1\n2\ngit clone https://github.com/mapbox/tippecanoe.git\n\ncd\n tippecanoe\n\n\n\n\n\n\nCompilar:\n\n\n1\n2\nmake -j\nsudo make install\n\n\n\n\n\n\nComprobar la instalaci\u00f3n:\n\n\n1\ntippecanoe -v \n# Devolver\u00e1, por ejemplo, v1.29.0\n\n\n\n\n\n\n\nUna vez instalado el ejecutable, podemos borrar el c\u00f3digo fuente:\n\n\n1\n2\ncd\n ..\nrm -rf tippecanoe\n\n\n\n\n\n\n\n\n\n\n\n\nDanger\n\n\nTodo el taller se basa en tener un navegador con capacidades WebGL, que deber\u00eda\n poder moverse R\u00c1PIDO.\n\n\n\n\nComprobar que al abrirse esta p\u00e1gina, se ve un mapa de Barcelona con edificios:\n\nhttp://tileserver.fonts.cat/styles/dark-matter-3d/?vector#16.09/41.3861/2.19226/-47.2/60\n\n\nComprobar que el mapa se mueve con soltura.\n\n\nSi no se puede correr el SO nativo (ser\u00eda lo ideal), ajustar la configuraci\u00f3n\nde VirtualBox para tener activadas las opciones:\n\n\nSystem \n Processor \n \"Enable PAE/NX\"\n\n\nDisplay \n Screen \n Aumentar MB disponibles para la tarjeta gr\u00e1fica.\n\n\nDisplay \n Screen \n \"Enable 3D acceleration\".\n\n\nTener instaladas las \"VirtualBox Guest Additions\" en la m\u00e1quina virtual.\n\n\n\n\n\n\n\n\n\n\nRecursos adicionales\n\n\nMayormente de \nRaf\n, nuestra fuente diaria de vitaminas, v\u00eda \nGeoinquiets\n. \n\n\n\n\nAwesome Vector Tiles\n \n\n\nNatural Earth Vector Tiles by Lukas Martinelli\n\n\nTutorial de los Geoinquietos de Londres\n\n\nTilemaker, de OSM a mbtiles de una tacada\n\n\nQu\u00e9 son las teselas vectoriales (vector tiles) y c\u00f3mo generarlos con PostGIS / GeoServer\n\n\nNatural Earth Quickstart Style implemented with Tegola\n\n\nGeoServer MBStyle Cookbook\n\n\nGeoServer MBStyle Styling Workbook", 
            "title": "Home"
        }, 
        {
            "location": "/#trabajando-con-teselas-vectoriales", 
            "text": "Bienvenidos al taller de teselas vectoriales. Este manual est\u00e1 publicado aqu\u00ed:", 
            "title": "Trabajando con teselas vectoriales"
        }, 
        {
            "location": "/#httpsgeoinquietsgithubiotaller-vt", 
            "text": "", 
            "title": "https://geoinquiets.github.io/taller-vt/"
        }, 
        {
            "location": "/#esenciales-para-moverse-por-osgeo-live", 
            "text": "Usuario: \"user\"  Password: \"user\"  Alt + F2  Para lanzar un programa de forma r\u00e1pida  Shift + Ctrl + V  para pegar un texto del portapapeles en el terminal", 
            "title": "Esenciales para moverse por OSGeo Live"
        }, 
        {
            "location": "/#descarga-de-los-materiales-para-el-taller", 
            "text": "1\n2\n3\n4\n5 cd  Desktop\nwget https://geoinquiets.github.io/taller-vt/downloads/taller-vt.zip\nunzip taller-vt.zip cd  taller-vt\nll   As\u00ed pues, la ruta  ~/Desktop/taller-vt  ser\u00e1 nuestro directorio base, donde iremos creando los recursos necesarios.\nDe momento tenemos los subdirectorios:   datos  maputnik", 
            "title": "Descarga de los materiales para el taller"
        }, 
        {
            "location": "/#comprobacion-del-software-preinstalado", 
            "text": "En el aula de la pr\u00e1ctica se ha preinstalado una serie de software necesario para el taller.\nEn caso de que falte alguno, se pueden consultar las instrucciones de instalaci\u00f3n en el siguiente apartado.  Comandos de comprobaci\u00f3n:    Alt + F2  =  \"terminator\" deber\u00eda abrir un terminal.  google-chrome http://tileserver.fonts.cat/styles/dark-matter/style.json  deber\u00eda abrir Chrome y mostrar un JSON formateado y coloreado.  google-chrome http://tileserver.fonts.cat/styles/dark-matter-3d/?vector#16.09/41.3861/2.19226/-47.2/60  deber\u00eda mostrar un mapa de Barcelona con edificios en 3D, y moverse con soltura.  node -v  Deber\u00eda ser 6.x.x (NO mayor que 6, si aparece 8.x.x o 10.x.x, hay que cambiar de versi\u00f3n)  npm -v  code -v  tippecanoe -v", 
            "title": "Comprobaci\u00f3n del software preinstalado"
        }, 
        {
            "location": "/#instalacion-de-requisitos-de-software", 
            "text": "El software de base para el taller ya est\u00e1 instalado en los ordenadores del aula, pero indicamos aqu\u00ed c\u00f3mo instalarlo\ntomando como base OSGeo Live 11 (tambi\u00e9n valdr\u00e1 para Ubuntu 16.04, en el que adem\u00e1s deber\u00eda instalarse PostGIS).   Google Chrome  La extensi\u00f3n  json-viewer  en Chrome  Microsoft Visual Studio Code  Terminator:\n     1 sudo apt install terminator    node6 y npm (sobre nvm):  Primero, instalar nvm:  1   curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh  |  bash   Cerrar y reabrir el terminal.\nLuego, instalar node 6 y npm:  1\n2\n3\n4\n5   nvm install 6\n  npm install -g npm\n  # comprobar versiones\n  node -v # Deber\u00eda ser 6.x.x\n  npm -v # Deber\u00eda ser 6.x.x o mayor     tippecanoe:  Instalar dependencias (librer\u00edas sqlite3 y zlib):  1 sudo apt install build-essential libsqlite3-dev zlib1g-dev   Bajarse el c\u00f3digo fuente:  1\n2 git clone https://github.com/mapbox/tippecanoe.git cd  tippecanoe   Compilar:  1\n2 make -j\nsudo make install   Comprobar la instalaci\u00f3n:  1 tippecanoe -v  # Devolver\u00e1, por ejemplo, v1.29.0    Una vez instalado el ejecutable, podemos borrar el c\u00f3digo fuente:  1\n2 cd  ..\nrm -rf tippecanoe      Danger  Todo el taller se basa en tener un navegador con capacidades WebGL, que deber\u00eda\n poder moverse R\u00c1PIDO.   Comprobar que al abrirse esta p\u00e1gina, se ve un mapa de Barcelona con edificios: http://tileserver.fonts.cat/styles/dark-matter-3d/?vector#16.09/41.3861/2.19226/-47.2/60  Comprobar que el mapa se mueve con soltura.  Si no se puede correr el SO nativo (ser\u00eda lo ideal), ajustar la configuraci\u00f3n\nde VirtualBox para tener activadas las opciones:  System   Processor   \"Enable PAE/NX\"  Display   Screen   Aumentar MB disponibles para la tarjeta gr\u00e1fica.  Display   Screen   \"Enable 3D acceleration\".  Tener instaladas las \"VirtualBox Guest Additions\" en la m\u00e1quina virtual.", 
            "title": "Instalaci\u00f3n de requisitos de software"
        }, 
        {
            "location": "/#recursos-adicionales", 
            "text": "Mayormente de  Raf , nuestra fuente diaria de vitaminas, v\u00eda  Geoinquiets .    Awesome Vector Tiles    Natural Earth Vector Tiles by Lukas Martinelli  Tutorial de los Geoinquietos de Londres  Tilemaker, de OSM a mbtiles de una tacada  Qu\u00e9 son las teselas vectoriales (vector tiles) y c\u00f3mo generarlos con PostGIS / GeoServer  Natural Earth Quickstart Style implemented with Tegola  GeoServer MBStyle Cookbook  GeoServer MBStyle Styling Workbook", 
            "title": "Recursos adicionales"
        }, 
        {
            "location": "/1_teoria/", 
            "text": "Qu\u00e9 son las teselas vectoriales\n\n\nLas teselas vectoriales son un formato de datos liviano para almacenar datos vectoriales geoespaciales, como puntos, l\u00edneas y pol\u00edgonos. Las teselas vectoriales codifican informaci\u00f3n geogr\u00e1fica de acuerdo con la especificaci\u00f3n de teselas vector de Mapbox. La especificaci\u00f3n de Mapbox es un est\u00e1ndar abierto bajo una licencia Creative Commons Attribution 3.0 US.\n\n\nUna tesela vectorial (vector tiles) contiene datos vectoriales georreferenciados (puede contener m\u00faltiples capas), recortados en teselas para facilitar su recuperaci\u00f3n. Son equivalentes a las teselas raster tradicionales (WMTS, TMS) pero retornan datos vectoriales en lugar de una imagen.\n\n\nCada conjunto de teselas vectoriales tiene su propio esquema. Un esquema consiste en nombres de capas, atributos, selecci\u00f3n de elementos, etc.\n\n\nNo existe un esquema que sirva para todo. Existen varios esquemas como por ejemplo: OpenMapTiles, Mapbox Streets, etc.\n\n\nUn poco de Historia\n\n\nExiste una larga historia de uso de teselas vectoriales en SIG. En 1966 el Sistema de Informaci\u00f3n Geogr\u00e1fica de Canad\u00e1 (CGIS), utilizaba un esquema de almacenamiento vectorial que permit\u00eda a las computadoras de recursos limitados acceder de manera eficiente y procesar datos de mapas vectoriales. CGIS us\u00f3 el t\u00e9rmino \"marco\" en lugar de teselas vectoriales.\n\n\nEn 1975, el Servicio de Vida Silvestre de los EE.UU. inici\u00f3 un programa nacional para mapear y digitalizar todos los humedales de los EE.UU. En 1976 desarrollan un software que se llam\u00f3 WAMS (Wetlands Analytical Mapping System). El almacenage de datos del WAMS usaba una estructura de teselas vectorial. Cada tesela se llamaba \"geounit\". Una geounit correspond\u00eda a una de las escalas cuadrangulares del USGS, generalmente 1:24000.\n\n\nEn 1986 bas\u00e1ndose en la experiencia operativa adquirida en la implementaci\u00f3n y el uso de WAMS y del Map Overlay and Statistical System (MOSS), se lanz\u00f3 un SIG comercial DeltaMap (m\u00e1s tarde GenaMap) basado en UNIX que implement\u00f3 una estructura mejorada de almacenamiento y acceso de teselas vectores. DeltaMap permiti\u00f3 al usuario definir cualquier tama\u00f1o de tesela en cualquier sistema de referencia de coordenadas (CRS). De esta forma, los datos dispersos requer\u00edan solo unas pocas teselas, mientras que los datos densos pod\u00edan usar teselas mucho m\u00e1s peque\u00f1as. Utilizaban R-trees como el esquema de indexaci\u00f3n para las teselas de vectores.\n\n\nA finales de la d\u00e9cada de 1980, se mejor\u00f3 a\u00fan m\u00e1s GenaMap para permitir el procesamiento \"continuo e ininterrumpido\" de las capas de teselas. B\u00e1sicamente, desde la perspectiva del usuario final, las teselas se volvieron invisibles. [^1]\n\n\n[^1] \nhttps://en.wikipedia.org/wiki/Vector_tiles\n\n\nAbril de 2014 Mapbox saca la version 1.0 de la especificaci\u00f3n Mapbox Vector Tile (MVT).\n\n\nDiciembre 2015 versi\u00f3n 2.0 de la especificaci\u00f3n MVT.\n\n\nMarzo de 2015 ESRI (el que no debe ser nombrado) anuncia que soportar\u00e1 MVT.\n\n\nMapbox actualmente est\u00e1 trabajando en la versi\u00f3n 3.\n\n\nDiferencias entre teselas raster y teselas vectoriales\n\n\n\n\nEl estilo se define en el cliente (vector) y no en el servidor (raster)\n\n\nTeselas vectoriales s\u00f3lo se necesita teselar la informaci\u00f3n una sola vez y se pueden tener m\u00faltiples mapas\n\n\nVectores se ven mejor en dispositivos de alta resoluci\u00f3n\n\n\nTeselas raster son m\u00e1s f\u00e1ciles de consumir.\n\n\nEl tama\u00f1o de una tesela vectorial (se recomienda m\u00e1ximo 500kb) suele ser menor que una tesela de im\u00e1genes (promedio 75% m\u00e1s peque\u00f1as), lo que permite una mayor velocidad de transferencia.\n\n\nEl cliente tiene acceso nativo a la informaci\u00f3n actual del objeto geogr\u00e1fico (atributos y geometr\u00eda), lo que permite un procesamiento muy sofisticado.\n\n\nLas cache de datos vectoriales ocupa mucho menos espacio que las restar. Esto hace que sea f\u00e1ctible el uso de teselas vectorials en dispositivos m\u00f3viles sin conexi\u00f3n.\n\n\nLas teselas vectoriales permiten \nOverzoom\n sin perder resoluci\u00f3n. Con las teselas raster si queremos hacer un zoom a un nivel mayor del que est\u00e1 definido la imagen se ver\u00e1 borrosa y pixelada.\n\n\n\n\n\nComparativa pesos teselas vector vs raster. Fuente \nhttps://plot.ly/~mourner/118.embed\n\n\nComparaci\u00f3n con otros formatos\n\n\nWMS\n\n\n\n\nNo teselado, con lo cual no hay problemas de etiquetas, etc\n\n\nSe puede imprimir pero hay problemas con Hi-DPI\n\n\n\n\nWMTS\n\n\n\n\nEscalabilidad\n\n\nCache tanto en cliente como en servidor\n\n\n\n\nWFS\n\n\n\n\nRetorna datos en vector sin modificar\n\n\n\n\nVector Tiles\n\n\n\n\nEscalabilidad\n\n\nCache tanto en cliente como en servidor\n\n\nInteractivo\n\n\nEstilo flexible (cliente es quien define el estilo)\n\n\nHi-DPI (impresi\u00f3n)\n\n\nRetorna datos en vector modificados (generalizados, simplificados)\n\n\n\n\nC\u00f3mo est\u00e1n hechas por dentro\n\n\nLas geometr\u00edas y los atributos se codifican como datos binarios de Google Protobuf (PBF).\n\n\nCodificar geometr\u00edas\n\n\nPara codificar informaci\u00f3n geogr\u00e1fica en una tesela vectorial, una herramienta debe convertir las coordenadas geogr\u00e1ficas, como la latitud y la longitud, en coordenadas vectoriales de cuadr\u00edculas. Las teselas de vectoriales no tienen ning\u00fan concepto de informaci\u00f3n geogr\u00e1fica. Codifican puntos, l\u00edneas y pol\u00edgonos como pares x/y relativos a la esquina superior izquierda de la cuadr\u00edcula de forma descendente.\n\n\nLas geometr\u00edas son transformadas a una sola tesela, con un sistema de coordenadas de p\u00edxel local, que por defecto va de la esquina superior izquierda (0,0) a la esquina inferior derecha (4096,4096).\n\n\n\n\nCodificar geometr\u00eda. Fuente \nhttps://www.mapbox.com/vector-tiles/specification/#encoding-geom\n\n\nCodificar atributos\n\n\nlos atributos de caracter\u00edsticas se codifican como un conjunto \u00fanico de claves (algo as\u00ed como un esquema de campos de capa) y la lista de sus valores.\n\n\nLos atributos est\u00e1n codificados en una serie de etiquetas que existen dentro de un elemento en el vector que tienen valores enteros que hacen referencia a las claves y los valores que provienen de la geometr\u00eda. Para geometr\u00edas grandes, esto elimina la redundancia de los atributos que tienen las mismas claves y valores similares.\n\n\n\n\nCodificar atributos. Fuente \nhttps://www.mapbox.com/vector-tiles/specification/#encoding-attr\n\n\nWinding order\n\n\nEl \nWinding order\n(direcci\u00f3n de digitalizaci\u00f3n) se refiere a la direcci\u00f3n en que se dibuja un anillo en un mosaico vectorial, ya sea en sentido horario o antihorario. Muchas geometr\u00edas son multipol\u00edgonos con \"agujeros\", que tambi\u00e9n se representan como anillos de pol\u00edgono. Es importante poder inferir orden para extraer datos fuente de un mosaico vectorial y comprender si la geometr\u00eda es parte de un pol\u00edgono m\u00faltiple o un pol\u00edgono \u00fanico.\n\n\nPara que los procesadores distingan de manera apropiada qu\u00e9 pol\u00edgonos son agujeros y cu\u00e1les son geometr\u00edas \u00fanicas, la especificaci\u00f3n requiere que todos los pol\u00edgonos sean v\u00e1lidos (validez de OGC). Cualquier anillo interior poligonal debe orientarse con el orden opuesto al de su anillo exterior principal y todos los anillos interiores deben seguir directamente el anillo exterior al que pertenecen. Los anillos exteriores deben estar orientados en el sentido de las agujas del reloj y los anillos interiores deben estar orientados en sentido contrario a las agujas del reloj.\n\n\n\n\nWinding order. Fuente \nhttps://www.mapbox.com/vector-tiles/specification/#winding-order\n\n\nDiferentes especificaciones y conceptos relacionados con las teselas vectoriales\n\n\npbf\n\n\nProtocol buffers\n desarrollado por Google (para uso interno) es un m\u00e9todo para serializar datos estructurados. Es language-neutral, platform-neutral y cuyo objetivo de dise\u00f1o enfatizaron la simplicidad y el rendimiento.\n\n\nEl m\u00e9todo implica un lenguaje de descripci\u00f3n de interfaz que describe la estructura de algunos datos y un programa que genera c\u00f3digo fuente a partir de esa descripci\u00f3n para generar o analizar una secuencia de bytes que representa los datos estructurados.\n\n\nmvt\n\n\nFormato binario basado en la especificaci\u00f3n de Mapbox que usa \npbf\n para serializar datos geogr\u00e1ficos. Los archivos deber\u00edan tener extensi\u00f3n .mvt pero no es obligatorio as\u00ed que se pueden encontrar archivos con extensi\u00f3n .pbf, .vector.pbf o .mvt.gz (compresi\u00f3n gzip)\n\n\nPor ejemplo un conjunto de teselas mvt almacenadas en un SQLite siguiendo una esquema espec\u00edfico formar\u00eda un MBTiles.\n\n\nMBTiles\n\n\nMBTiles\n es un formato de archivo para almacenar conjuntos de teselas. Est\u00e1 dise\u00f1ado para que pueda empaquetar los potencialmente miles de archivos que componen un conjunto de teselas y moverlos, eventualmente subirlos a Mapbox o usarlos en una aplicaci\u00f3n web o m\u00f3vil. MBTiles es una especificaci\u00f3n abierta y se basa en la base de datos SQLite. MBTiles puede contener conjunto de teselas reaster o vector.\n\n\nMBTiles es una especificaci\u00f3n compacta y restrictiva. Solo admite datos teselados, incluidas teselas vectoriales o de im\u00e1genes y UTFGrid (hasta la versi\u00f3n 1.2). Solo la proyecci\u00f3n esf\u00e9rica de Mercator es soportada para la presentaci\u00f3n (visualizaci\u00f3n) y solo se admiten coordenadas de latitud y longitud para metadatos, como l\u00edmites y centros.\n\n\nEs una especificaci\u00f3n m\u00ednima, que solo especifica las formas en que los datos deben ser recuperables. Por lo tanto, los archivos MBTiles pueden comprimir y optimizar datos internamente, y construir vistas que se adhieren a la especificaci\u00f3n MBTiles. Dentro del MBtiles los vectores estan almacenados comprimidos (gzip) y en formato pbf.\n\n\nA diferencia de Spatialite, GeoJSON y Rasterlite, MBTiles no es un almacenamiento de datos sin formato. Es almacenamiento de datos en teselas.\n\n\ntilejson\n\n\nTileJSON\n es un formato para describir un conjunto de teselas. Realiza un seguimiento de d\u00f3nde solicitar el conjunto de teselas, el nombre del conjunto de teselas y cualquier atribuci\u00f3n que sea necesaria al utilizar el conjunto de teselas.\n\n\nEsta especificaci\u00f3n intenta crear un est\u00e1ndar para representar metadatos sobre m\u00faltiples tipos de capas, para ayudar a los clientes en la configuraci\u00f3n y navegaci\u00f3n.\n\n\nOverzoom\n\n\nOverzooming\n es una t\u00e9cnica espec\u00edfica de teselas vectorial que permite que una tesela se represente m\u00e1s all\u00e1 de su nivel de zoom previsto, por lo que contin\u00faa siendo visible en el mapa. Si un conjunto de teselas tiene un minzoom de 6 y un maxzoom de 12, esos son los rangos v\u00e1lidos calculados por el generador de teselas. Si ampliara el mapa m\u00e1s all\u00e1 del nivel de zoom 12, el renderizador del mapa puede seguir utilizando los datos del zoom 12 escalando los datos del vector hacia arriba. Esto, por supuesto, puede dar lugar a grandes simplificaciones de datos si las geometr\u00edas se representan demasiado por encima de su nivel real de detalle.\n\n\nLas teselas r\u00e1ster pierden claridad si ocurre overzoom. Por ejemplo, si est\u00e1 visualizando un conjunto de teselas reaster con una extensi\u00f3n de zoom entre z0 y z6, si hace un zoom a un nivel de zoom m\u00e1s alto despu\u00e9s de z6, las im\u00e1genes se volver\u00e1n borrosas y dif\u00edciles de ver.\n\n\nLos efectos del overzoom no son tan notables con los tilesets de vector, ya que los datos vectoriales no se almacenan en un formato basado en p\u00edxeles, sino que se codifican y calculan a partir de una serie de puntos, l\u00edneas y pol\u00edgonos.\n\n\nPresentaci\u00f3n de ejemplos visuales hechos con vt\n\n\nTerreno\n\n\nhttps://openicgc.github.io/\n\n\n\n\nLuces LA\n\n\n\n\nEdificios con m\u00fasica\n\n\nhttps://codepen.io/jwhazel/pen/NYzpWG\n\n\n\n\nblog explicativo \nhttps://medium.com/@erdag/mappox-mapmadness18-round-4-1251a8c10421\n\n\nTem\u00e1tico filtro\n\n\n\n\nMapa de calor\n\n\n\n\nExponer esquema general de lo que se va a hacer en el taller.\n\n\n\n\nEsquema taller\n\n\nTODO\n\n\n\n\npara qu\u00e9 sirven y para qu\u00e9 no,", 
            "title": "1. Qu\u00e9 son"
        }, 
        {
            "location": "/1_teoria/#que-son-las-teselas-vectoriales", 
            "text": "Las teselas vectoriales son un formato de datos liviano para almacenar datos vectoriales geoespaciales, como puntos, l\u00edneas y pol\u00edgonos. Las teselas vectoriales codifican informaci\u00f3n geogr\u00e1fica de acuerdo con la especificaci\u00f3n de teselas vector de Mapbox. La especificaci\u00f3n de Mapbox es un est\u00e1ndar abierto bajo una licencia Creative Commons Attribution 3.0 US.  Una tesela vectorial (vector tiles) contiene datos vectoriales georreferenciados (puede contener m\u00faltiples capas), recortados en teselas para facilitar su recuperaci\u00f3n. Son equivalentes a las teselas raster tradicionales (WMTS, TMS) pero retornan datos vectoriales en lugar de una imagen.  Cada conjunto de teselas vectoriales tiene su propio esquema. Un esquema consiste en nombres de capas, atributos, selecci\u00f3n de elementos, etc.  No existe un esquema que sirva para todo. Existen varios esquemas como por ejemplo: OpenMapTiles, Mapbox Streets, etc.", 
            "title": "Qu\u00e9 son las teselas vectoriales"
        }, 
        {
            "location": "/1_teoria/#un-poco-de-historia", 
            "text": "Existe una larga historia de uso de teselas vectoriales en SIG. En 1966 el Sistema de Informaci\u00f3n Geogr\u00e1fica de Canad\u00e1 (CGIS), utilizaba un esquema de almacenamiento vectorial que permit\u00eda a las computadoras de recursos limitados acceder de manera eficiente y procesar datos de mapas vectoriales. CGIS us\u00f3 el t\u00e9rmino \"marco\" en lugar de teselas vectoriales.  En 1975, el Servicio de Vida Silvestre de los EE.UU. inici\u00f3 un programa nacional para mapear y digitalizar todos los humedales de los EE.UU. En 1976 desarrollan un software que se llam\u00f3 WAMS (Wetlands Analytical Mapping System). El almacenage de datos del WAMS usaba una estructura de teselas vectorial. Cada tesela se llamaba \"geounit\". Una geounit correspond\u00eda a una de las escalas cuadrangulares del USGS, generalmente 1:24000.  En 1986 bas\u00e1ndose en la experiencia operativa adquirida en la implementaci\u00f3n y el uso de WAMS y del Map Overlay and Statistical System (MOSS), se lanz\u00f3 un SIG comercial DeltaMap (m\u00e1s tarde GenaMap) basado en UNIX que implement\u00f3 una estructura mejorada de almacenamiento y acceso de teselas vectores. DeltaMap permiti\u00f3 al usuario definir cualquier tama\u00f1o de tesela en cualquier sistema de referencia de coordenadas (CRS). De esta forma, los datos dispersos requer\u00edan solo unas pocas teselas, mientras que los datos densos pod\u00edan usar teselas mucho m\u00e1s peque\u00f1as. Utilizaban R-trees como el esquema de indexaci\u00f3n para las teselas de vectores.  A finales de la d\u00e9cada de 1980, se mejor\u00f3 a\u00fan m\u00e1s GenaMap para permitir el procesamiento \"continuo e ininterrumpido\" de las capas de teselas. B\u00e1sicamente, desde la perspectiva del usuario final, las teselas se volvieron invisibles. [^1]  [^1]  https://en.wikipedia.org/wiki/Vector_tiles  Abril de 2014 Mapbox saca la version 1.0 de la especificaci\u00f3n Mapbox Vector Tile (MVT).  Diciembre 2015 versi\u00f3n 2.0 de la especificaci\u00f3n MVT.  Marzo de 2015 ESRI (el que no debe ser nombrado) anuncia que soportar\u00e1 MVT.  Mapbox actualmente est\u00e1 trabajando en la versi\u00f3n 3.", 
            "title": "Un poco de Historia"
        }, 
        {
            "location": "/1_teoria/#diferencias-entre-teselas-raster-y-teselas-vectoriales", 
            "text": "El estilo se define en el cliente (vector) y no en el servidor (raster)  Teselas vectoriales s\u00f3lo se necesita teselar la informaci\u00f3n una sola vez y se pueden tener m\u00faltiples mapas  Vectores se ven mejor en dispositivos de alta resoluci\u00f3n  Teselas raster son m\u00e1s f\u00e1ciles de consumir.  El tama\u00f1o de una tesela vectorial (se recomienda m\u00e1ximo 500kb) suele ser menor que una tesela de im\u00e1genes (promedio 75% m\u00e1s peque\u00f1as), lo que permite una mayor velocidad de transferencia.  El cliente tiene acceso nativo a la informaci\u00f3n actual del objeto geogr\u00e1fico (atributos y geometr\u00eda), lo que permite un procesamiento muy sofisticado.  Las cache de datos vectoriales ocupa mucho menos espacio que las restar. Esto hace que sea f\u00e1ctible el uso de teselas vectorials en dispositivos m\u00f3viles sin conexi\u00f3n.  Las teselas vectoriales permiten  Overzoom  sin perder resoluci\u00f3n. Con las teselas raster si queremos hacer un zoom a un nivel mayor del que est\u00e1 definido la imagen se ver\u00e1 borrosa y pixelada.   \nComparativa pesos teselas vector vs raster. Fuente  https://plot.ly/~mourner/118.embed", 
            "title": "Diferencias entre teselas raster y teselas vectoriales"
        }, 
        {
            "location": "/1_teoria/#comparacion-con-otros-formatos", 
            "text": "", 
            "title": "Comparaci\u00f3n con otros formatos"
        }, 
        {
            "location": "/1_teoria/#wms", 
            "text": "No teselado, con lo cual no hay problemas de etiquetas, etc  Se puede imprimir pero hay problemas con Hi-DPI", 
            "title": "WMS"
        }, 
        {
            "location": "/1_teoria/#wmts", 
            "text": "Escalabilidad  Cache tanto en cliente como en servidor", 
            "title": "WMTS"
        }, 
        {
            "location": "/1_teoria/#wfs", 
            "text": "Retorna datos en vector sin modificar", 
            "title": "WFS"
        }, 
        {
            "location": "/1_teoria/#vector-tiles", 
            "text": "Escalabilidad  Cache tanto en cliente como en servidor  Interactivo  Estilo flexible (cliente es quien define el estilo)  Hi-DPI (impresi\u00f3n)  Retorna datos en vector modificados (generalizados, simplificados)", 
            "title": "Vector Tiles"
        }, 
        {
            "location": "/1_teoria/#como-estan-hechas-por-dentro", 
            "text": "Las geometr\u00edas y los atributos se codifican como datos binarios de Google Protobuf (PBF).", 
            "title": "C\u00f3mo est\u00e1n hechas por dentro"
        }, 
        {
            "location": "/1_teoria/#codificar-geometrias", 
            "text": "Para codificar informaci\u00f3n geogr\u00e1fica en una tesela vectorial, una herramienta debe convertir las coordenadas geogr\u00e1ficas, como la latitud y la longitud, en coordenadas vectoriales de cuadr\u00edculas. Las teselas de vectoriales no tienen ning\u00fan concepto de informaci\u00f3n geogr\u00e1fica. Codifican puntos, l\u00edneas y pol\u00edgonos como pares x/y relativos a la esquina superior izquierda de la cuadr\u00edcula de forma descendente.  Las geometr\u00edas son transformadas a una sola tesela, con un sistema de coordenadas de p\u00edxel local, que por defecto va de la esquina superior izquierda (0,0) a la esquina inferior derecha (4096,4096).   Codificar geometr\u00eda. Fuente  https://www.mapbox.com/vector-tiles/specification/#encoding-geom", 
            "title": "Codificar geometr\u00edas"
        }, 
        {
            "location": "/1_teoria/#codificar-atributos", 
            "text": "los atributos de caracter\u00edsticas se codifican como un conjunto \u00fanico de claves (algo as\u00ed como un esquema de campos de capa) y la lista de sus valores.  Los atributos est\u00e1n codificados en una serie de etiquetas que existen dentro de un elemento en el vector que tienen valores enteros que hacen referencia a las claves y los valores que provienen de la geometr\u00eda. Para geometr\u00edas grandes, esto elimina la redundancia de los atributos que tienen las mismas claves y valores similares.   Codificar atributos. Fuente  https://www.mapbox.com/vector-tiles/specification/#encoding-attr", 
            "title": "Codificar atributos"
        }, 
        {
            "location": "/1_teoria/#winding-order", 
            "text": "El  Winding order (direcci\u00f3n de digitalizaci\u00f3n) se refiere a la direcci\u00f3n en que se dibuja un anillo en un mosaico vectorial, ya sea en sentido horario o antihorario. Muchas geometr\u00edas son multipol\u00edgonos con \"agujeros\", que tambi\u00e9n se representan como anillos de pol\u00edgono. Es importante poder inferir orden para extraer datos fuente de un mosaico vectorial y comprender si la geometr\u00eda es parte de un pol\u00edgono m\u00faltiple o un pol\u00edgono \u00fanico.  Para que los procesadores distingan de manera apropiada qu\u00e9 pol\u00edgonos son agujeros y cu\u00e1les son geometr\u00edas \u00fanicas, la especificaci\u00f3n requiere que todos los pol\u00edgonos sean v\u00e1lidos (validez de OGC). Cualquier anillo interior poligonal debe orientarse con el orden opuesto al de su anillo exterior principal y todos los anillos interiores deben seguir directamente el anillo exterior al que pertenecen. Los anillos exteriores deben estar orientados en el sentido de las agujas del reloj y los anillos interiores deben estar orientados en sentido contrario a las agujas del reloj.   Winding order. Fuente  https://www.mapbox.com/vector-tiles/specification/#winding-order", 
            "title": "Winding order"
        }, 
        {
            "location": "/1_teoria/#diferentes-especificaciones-y-conceptos-relacionados-con-las-teselas-vectoriales", 
            "text": "", 
            "title": "Diferentes especificaciones y conceptos relacionados con las teselas vectoriales"
        }, 
        {
            "location": "/1_teoria/#pbf", 
            "text": "Protocol buffers  desarrollado por Google (para uso interno) es un m\u00e9todo para serializar datos estructurados. Es language-neutral, platform-neutral y cuyo objetivo de dise\u00f1o enfatizaron la simplicidad y el rendimiento.  El m\u00e9todo implica un lenguaje de descripci\u00f3n de interfaz que describe la estructura de algunos datos y un programa que genera c\u00f3digo fuente a partir de esa descripci\u00f3n para generar o analizar una secuencia de bytes que representa los datos estructurados.", 
            "title": "pbf"
        }, 
        {
            "location": "/1_teoria/#mvt", 
            "text": "Formato binario basado en la especificaci\u00f3n de Mapbox que usa  pbf  para serializar datos geogr\u00e1ficos. Los archivos deber\u00edan tener extensi\u00f3n .mvt pero no es obligatorio as\u00ed que se pueden encontrar archivos con extensi\u00f3n .pbf, .vector.pbf o .mvt.gz (compresi\u00f3n gzip)  Por ejemplo un conjunto de teselas mvt almacenadas en un SQLite siguiendo una esquema espec\u00edfico formar\u00eda un MBTiles.", 
            "title": "mvt"
        }, 
        {
            "location": "/1_teoria/#mbtiles", 
            "text": "MBTiles  es un formato de archivo para almacenar conjuntos de teselas. Est\u00e1 dise\u00f1ado para que pueda empaquetar los potencialmente miles de archivos que componen un conjunto de teselas y moverlos, eventualmente subirlos a Mapbox o usarlos en una aplicaci\u00f3n web o m\u00f3vil. MBTiles es una especificaci\u00f3n abierta y se basa en la base de datos SQLite. MBTiles puede contener conjunto de teselas reaster o vector.  MBTiles es una especificaci\u00f3n compacta y restrictiva. Solo admite datos teselados, incluidas teselas vectoriales o de im\u00e1genes y UTFGrid (hasta la versi\u00f3n 1.2). Solo la proyecci\u00f3n esf\u00e9rica de Mercator es soportada para la presentaci\u00f3n (visualizaci\u00f3n) y solo se admiten coordenadas de latitud y longitud para metadatos, como l\u00edmites y centros.  Es una especificaci\u00f3n m\u00ednima, que solo especifica las formas en que los datos deben ser recuperables. Por lo tanto, los archivos MBTiles pueden comprimir y optimizar datos internamente, y construir vistas que se adhieren a la especificaci\u00f3n MBTiles. Dentro del MBtiles los vectores estan almacenados comprimidos (gzip) y en formato pbf.  A diferencia de Spatialite, GeoJSON y Rasterlite, MBTiles no es un almacenamiento de datos sin formato. Es almacenamiento de datos en teselas.", 
            "title": "MBTiles"
        }, 
        {
            "location": "/1_teoria/#tilejson", 
            "text": "TileJSON  es un formato para describir un conjunto de teselas. Realiza un seguimiento de d\u00f3nde solicitar el conjunto de teselas, el nombre del conjunto de teselas y cualquier atribuci\u00f3n que sea necesaria al utilizar el conjunto de teselas.  Esta especificaci\u00f3n intenta crear un est\u00e1ndar para representar metadatos sobre m\u00faltiples tipos de capas, para ayudar a los clientes en la configuraci\u00f3n y navegaci\u00f3n.", 
            "title": "tilejson"
        }, 
        {
            "location": "/1_teoria/#overzoom", 
            "text": "Overzooming  es una t\u00e9cnica espec\u00edfica de teselas vectorial que permite que una tesela se represente m\u00e1s all\u00e1 de su nivel de zoom previsto, por lo que contin\u00faa siendo visible en el mapa. Si un conjunto de teselas tiene un minzoom de 6 y un maxzoom de 12, esos son los rangos v\u00e1lidos calculados por el generador de teselas. Si ampliara el mapa m\u00e1s all\u00e1 del nivel de zoom 12, el renderizador del mapa puede seguir utilizando los datos del zoom 12 escalando los datos del vector hacia arriba. Esto, por supuesto, puede dar lugar a grandes simplificaciones de datos si las geometr\u00edas se representan demasiado por encima de su nivel real de detalle.  Las teselas r\u00e1ster pierden claridad si ocurre overzoom. Por ejemplo, si est\u00e1 visualizando un conjunto de teselas reaster con una extensi\u00f3n de zoom entre z0 y z6, si hace un zoom a un nivel de zoom m\u00e1s alto despu\u00e9s de z6, las im\u00e1genes se volver\u00e1n borrosas y dif\u00edciles de ver.  Los efectos del overzoom no son tan notables con los tilesets de vector, ya que los datos vectoriales no se almacenan en un formato basado en p\u00edxeles, sino que se codifican y calculan a partir de una serie de puntos, l\u00edneas y pol\u00edgonos.", 
            "title": "Overzoom"
        }, 
        {
            "location": "/1_teoria/#presentacion-de-ejemplos-visuales-hechos-con-vt", 
            "text": "", 
            "title": "Presentaci\u00f3n de ejemplos visuales hechos con vt"
        }, 
        {
            "location": "/1_teoria/#terreno", 
            "text": "https://openicgc.github.io/", 
            "title": "Terreno"
        }, 
        {
            "location": "/1_teoria/#luces-la", 
            "text": "", 
            "title": "Luces LA"
        }, 
        {
            "location": "/1_teoria/#edificios-con-musica", 
            "text": "https://codepen.io/jwhazel/pen/NYzpWG   blog explicativo  https://medium.com/@erdag/mappox-mapmadness18-round-4-1251a8c10421", 
            "title": "Edificios con m\u00fasica"
        }, 
        {
            "location": "/1_teoria/#tematico-filtro", 
            "text": "", 
            "title": "Tem\u00e1tico filtro"
        }, 
        {
            "location": "/1_teoria/#mapa-de-calor", 
            "text": "", 
            "title": "Mapa de calor"
        }, 
        {
            "location": "/1_teoria/#exponer-esquema-general-de-lo-que-se-va-a-hacer-en-el-taller", 
            "text": "Esquema taller  TODO   para qu\u00e9 sirven y para qu\u00e9 no,", 
            "title": "Exponer esquema general de lo que se va a hacer en el taller."
        }, 
        {
            "location": "/2_visor_simple/", 
            "text": "C\u00f3mo visualizar teselas vectoriales\n\n\nServidor web\n\n\nPara ver las aplicaciones que desarrollaremos durante el taller necesitamos publicarlas mediante un servidor web.\nEn nuestro caso usaremos \nlive-server\n, que permite servir los contenidos de un directorio y recargar la p\u00e1gina\nautom\u00e1ticamente cuando se modifica el contenido de alg\u00fan fichero.\n\n\nPara instalarlo, se usar\u00e1 el comando:\n\n\n1\nsudo npm install -g live-server\n\n\n\n\n\n\nPara arrancarlo, basta con situarse en el directorio que queramos servir y ejecutar:\n\n\n1\n2\n3\nmkdir taller-vt\n\ncd\n taller-vt\nlive-server\n\n\n\n\n\n\nSe abrir\u00e1 el navegador por defecto con la direcci\u00f3n \nhttp://127.0.0.1:8080/\n\ny se mostrar\u00e1 el contenido del directorio para poder navegar por \u00e9l.\n\n\nDeja la ventana del terminal abierta, y usa la combinaci\u00f3n de teclas \nCtrl\n + \nC\n para parar el servidor.\n\n\nHola Mundo\n\n\nVamos a crear un fichero \nbarcelona.html\n.\n\n\nAbre una nueva ventana de terminal (recuerda dejar el servidor activo) y ejecuta Visual Studio Code\n(o el editor que prefieras):\n\n\n1\ncode .\n\n\n\n\n\n\nCrea un fichero \nbarcelona.html\n:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n!DOCTYPE html\n\n\nhtml\n\n\nhead\n\n    \nmeta\n \ncharset\n=\nUTF-8\n\n    \nmeta\n \nname\n=\nviewport\n \ncontent\n=\nwidth=device-width, initial-scale=1\n\n    \ntitle\nMapa VT\n/\ntitle\n\n\n/\nhead\n\n\nbody\n \nid\n=\nmap\n\n    \n#x1f596;\n \n#x1f30d;\n\n\n/\nbody\n\n\n/\nhtml\n\n\n\n\n\n\n\nRecargar la p\u00e1gina \nhttp://127.0.0.1:8080/\n en el navegador. Se deber\u00eda ver un \"Hola mundo\".\n\n\nHola Mapa\n\n\nEn este primer ejemplo crearemos un visor de mapas utilizando la librer\u00eda de Mapbox GL JS.\nTanto los datos procedente de teselas vectoriales \u00f3 vector tiles (VT) como el estilo para\nsimbolizar los mismos se encuentran en la red.\n\n\nModificar el archivo \nbarcelona.html\n para que contenga el siguiente c\u00f3digo:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n!DOCTYPE html\n\n\nhtml\n\n\nhead\n\n    \nmeta\n \ncharset\n=\nUTF-8\n\n    \nmeta\n \nname\n=\nviewport\n \ncontent\n=\nwidth=device-width, initial-scale=1\n\n    \ntitle\nMapa VT\n/\ntitle\n\n\n    \nlink\n \nrel\n=\nstylesheet\n \nhref\n=\nhttps://api.tiles.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.css\n \n/\n\n\n    \nscript\n \nsrc\n=\nhttps://api.tiles.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.js\n/\nscript\n\n\n    \nstyle\n\n\n        \nhtml\n,\n \nbody\n \n{\n\n\n            \nmargin\n:\n \n0\n;\n\n\n            \nheight\n:\n \n100\n%\n;\n\n\n        \n}\n\n\n    \n/\nstyle\n\n\n/\nhead\n\n\nbody\n \nid\n=\nmap\n\n\nscript\n\n\n    \nvar\n \nmap\n \n=\n \nnew\n \nmapboxgl\n.\nMap\n({\n\n\n        \ncontainer\n:\n \nmap\n,\n \n// id del elemento HTML que contendr\u00e1 el mapa\n\n\n        \nstyle\n:\n \nhttps://openmaptiles.github.io/osm-bright-gl-style/style-cdn.json\n,\n \n// Ubicaci\u00f3n del estilo\n\n\n        \ncenter\n:\n \n[\n2.175\n,\n \n41.39\n],\n \n// Ubicaci\u00f3n inicial\n\n\n        \nzoom\n:\n \n13\n,\n \n// Zoom inicial\n\n\n        \nbearing\n:\n \n-\n45\n,\n \n// \u00c1ngulo de rotaci\u00f3n inicial\n\n\n        \nhash\n:\n \ntrue\n \n// Permite ir guardando la posici\u00f3n del mapa en la URL\n\n\n    \n});\n\n\n\n\n    \n// Agrega controles de navegaci\u00f3n (zoom, rotaci\u00f3n) al mapa:\n\n\n    \nmap\n.\naddControl\n(\nnew\n \nmapboxgl\n.\nNavigationControl\n());\n\n\n/\nscript\n\n\n/\nbody\n\n\n/\nhtml\n\n\n\n\n\n\n\n\nResultado visor simple\n\n\nInspector de datos\n\n\nEl control \nmapbox-gl-inspect\n permite ver todos los elementos\nde un VT y tambi\u00e9n permite pasar el cursor sobre los elementos para ver sus propiedades.\n\n\nAgregar el c\u00f3digo de la librer\u00eda, e instanciar el control tras crear el mapa:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n!DOCTYPE html\n\n\nhtml\n\n\nhead\n\n    \nmeta\n \ncharset\n=\nUTF-8\n\n    \nmeta\n \nname\n=\nviewport\n \ncontent\n=\nwidth=device-width, initial-scale=1\n\n    \ntitle\nMapa VT\n/\ntitle\n\n    \nlink\n \nrel\n=\nstylesheet\n \nhref\n=\nhttps://api.tiles.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.css\n \n/\n\n    \nscript\n \nsrc\n=\nhttps://api.tiles.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.js\n/\nscript\n\n\n    \nlink\n \nhref\n=\nhttps://mapbox-gl-inspect.lukasmartinelli.ch/dist/mapbox-gl-inspect.css\n \nrel\n=\nstylesheet\n \n/\n\n\n    \nscript\n \nsrc\n=\nhttps://mapbox-gl-inspect.lukasmartinelli.ch/dist/mapbox-gl-inspect.min.js\n/\nscript\n\n\n    \nstyle\n\n        \nhtml\n,\n \nbody\n \n{\n\n            \nmargin\n:\n \n0\n;\n\n            \nheight\n:\n \n100\n%\n;\n\n        \n}\n\n    \n/\nstyle\n\n\n/\nhead\n\n\nbody\n \nid\n=\nmap\n\n\nscript\n\n    \nvar\n \nmap\n \n=\n \nnew\n \nmapboxgl\n.\nMap\n({\n\n        \ncontainer\n:\n \nmap\n,\n \n// id del elemento HTML que contendr\u00e1 el mapa\n\n        \nstyle\n:\n \nhttps://openmaptiles.github.io/osm-bright-gl-style/style-cdn.json\n,\n \n// Ubicaci\u00f3n del estilo\n\n        \ncenter\n:\n \n[\n2.175\n,\n \n41.39\n],\n \n// Ubicaci\u00f3n inicial\n\n        \nzoom\n:\n \n13\n,\n \n// Zoom inicial\n\n        \nbearing\n:\n \n-\n45\n,\n \n// \u00c1ngulo de rotaci\u00f3n inicial\n\n        \nhash\n:\n \ntrue\n \n// Permite ir guardando la posici\u00f3n del mapa en la URL\n\n    \n});\n\n\n    \n// Agrega controles de navegaci\u00f3n (zoom, rotaci\u00f3n) al mapa:\n\n    \nmap\n.\naddControl\n(\nnew\n \nmapboxgl\n.\nNavigationControl\n());\n\n\n\n    \n// Agregar el control de inspecci\u00f3n\n\n\n    \nmap\n.\naddControl\n(\nnew\n \nMapboxInspect\n());\n\n\n/\nscript\n\n\n/\nbody\n\n\n/\nhtml\n\n\n\n\n\n\n\nSe recargar\u00e1 la p\u00e1gina en el navegador con un nuevo bot\u00f3n que permite la \"visi\u00f3n de rayos X\" sobre los datos.\n\n\n\nResultado visor simple\n\n\nContenido de un fichero de estilo\n\n\nComo vemos, el visor es muy sencillo, y parece que toda la \"magia\" se esconde en el fichero de estilo tras la URL\n\nhttps://openmaptiles.github.io/osm-bright-gl-style/style-cdn.json\n.\n\n\nSi lo abrimos, es un objeto JSON bastante complejo, pero si nos fijamos en las propiedades de primer nivel, son pocas.\nLas principales: \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n{\n\n  \nversion\n:\n \n8\n,\n\n  \nname\n:\n \nOSM Bright\n,\n\n  \nsprite\n:\n \nhttps://openmaptiles.github.io/osm-bright-gl-style/sprite\n,\n\n  \nglyphs\n:\n \nhttps://free.tilehosting.com/fonts/{fontstack}/{range}.pbf?key=RiS4gsgZPZqeeMlIyxFo\n,\n\n  \nsources\n:\n \n{\n...\n},\n\n  \nlayers\n:\n \n[\n...\n]\n\n\n}\n\n\n\n\n\n\n\n\n\nversion\n es obligatoria y siempre es 8.\n\n\nname\n es opcional pero conveniente, es una etiqueta para mostrar el nombre del estilo. \n\n\nsprite\n indica de d\u00f3nde obtener el conjunto de \niconos\n necesarios para simbolizar.\n\n\nglyphs\n: indica de d\u00f3nde obtener el conjunto de \ntipograf\u00edas\n necesarios para simbolizar.\n\n\nsources\n: los or\u00edgenes de datos.\n\n\nlayers\n: las reglas de simbolizaci\u00f3n. El orden es importante: Se van dibujando de la primera (que queda por debajo)\na la \u00faltima (que queda por encima). As\u00ed, la primera regla suele ser el color de fondo del mapa, y las \u00faltimas suelen\nser la toponimia o los PoIs.\n\n\n\n\nEn los pr\u00f3ximos cap\u00edtulos veremos en detalle c\u00f3mo usar \nsources\n, \nlayers\n, \nsprites\n y \nglyphs\n.\n\n\nHabitualmente tambi\u00e9n se usan otras propiedades para indicar la vista inicial del mapa. Por ejemplo:\n\n\n1\n2\n3\n4\n5\n6\n7\n{\n\n  \n...\n\n  \ncenter\n:\n \n[\n2.15\n,\n \n41.39\n],\n\n  \nzoom\n:\n \n12\n,\n\n  \nbearing\n:\n \n-45\n,\n\n  \npitch\n:\n \n0\n\n\n}\n\n\n\n\n\n\n\n\n\ncenter\n: Coordenadas iniciales donde centrar el mapa [lon, lat]\n\n\nzoom\n: Zoom inicial del mapa\n\n\nbearing\n: Rotaci\u00f3n inicial del mapa (en grados)\n\n\npitch\n: Inclinaci\u00f3n inicial del mapa para verlo en perspectiva (de 0 a 60 grados)\n\n\n\n\n\n\nTip\n\n\nLa especificaci\u00f3n completa del fichero de estilo es parte de la \ndocumentaci\u00f3n on-line de Mapbox GL\nJS\n.", 
            "title": "2. C\u00f3mo visualizarlas"
        }, 
        {
            "location": "/2_visor_simple/#como-visualizar-teselas-vectoriales", 
            "text": "", 
            "title": "C\u00f3mo visualizar teselas vectoriales"
        }, 
        {
            "location": "/2_visor_simple/#servidor-web", 
            "text": "Para ver las aplicaciones que desarrollaremos durante el taller necesitamos publicarlas mediante un servidor web.\nEn nuestro caso usaremos  live-server , que permite servir los contenidos de un directorio y recargar la p\u00e1gina\nautom\u00e1ticamente cuando se modifica el contenido de alg\u00fan fichero.  Para instalarlo, se usar\u00e1 el comando:  1 sudo npm install -g live-server   Para arrancarlo, basta con situarse en el directorio que queramos servir y ejecutar:  1\n2\n3 mkdir taller-vt cd  taller-vt\nlive-server   Se abrir\u00e1 el navegador por defecto con la direcci\u00f3n  http://127.0.0.1:8080/ \ny se mostrar\u00e1 el contenido del directorio para poder navegar por \u00e9l.  Deja la ventana del terminal abierta, y usa la combinaci\u00f3n de teclas  Ctrl  +  C  para parar el servidor.", 
            "title": "Servidor web"
        }, 
        {
            "location": "/2_visor_simple/#hola-mundo", 
            "text": "Vamos a crear un fichero  barcelona.html .  Abre una nueva ventana de terminal (recuerda dejar el servidor activo) y ejecuta Visual Studio Code\n(o el editor que prefieras):  1 code .   Crea un fichero  barcelona.html :   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11 !DOCTYPE html  html  head \n     meta   charset = UTF-8 \n     meta   name = viewport   content = width=device-width, initial-scale=1 \n     title Mapa VT / title  / head  body   id = map \n     #x1f596;   #x1f30d;  / body  / html    Recargar la p\u00e1gina  http://127.0.0.1:8080/  en el navegador. Se deber\u00eda ver un \"Hola mundo\".", 
            "title": "Hola Mundo"
        }, 
        {
            "location": "/2_visor_simple/#hola-mapa", 
            "text": "En este primer ejemplo crearemos un visor de mapas utilizando la librer\u00eda de Mapbox GL JS.\nTanto los datos procedente de teselas vectoriales \u00f3 vector tiles (VT) como el estilo para\nsimbolizar los mismos se encuentran en la red.  Modificar el archivo  barcelona.html  para que contenga el siguiente c\u00f3digo:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31 !DOCTYPE html  html  head \n     meta   charset = UTF-8 \n     meta   name = viewport   content = width=device-width, initial-scale=1 \n     title Mapa VT / title       link   rel = stylesheet   href = https://api.tiles.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.css   /       script   src = https://api.tiles.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.js / script       style           html ,   body   {               margin :   0 ;               height :   100 % ;           }       / style  / head  body   id = map  script       var   map   =   new   mapboxgl . Map ({           container :   map ,   // id del elemento HTML que contendr\u00e1 el mapa           style :   https://openmaptiles.github.io/osm-bright-gl-style/style-cdn.json ,   // Ubicaci\u00f3n del estilo           center :   [ 2.175 ,   41.39 ],   // Ubicaci\u00f3n inicial           zoom :   13 ,   // Zoom inicial           bearing :   - 45 ,   // \u00c1ngulo de rotaci\u00f3n inicial           hash :   true   // Permite ir guardando la posici\u00f3n del mapa en la URL       });        // Agrega controles de navegaci\u00f3n (zoom, rotaci\u00f3n) al mapa:       map . addControl ( new   mapboxgl . NavigationControl ());  / script  / body  / html    \nResultado visor simple", 
            "title": "Hola Mapa"
        }, 
        {
            "location": "/2_visor_simple/#inspector-de-datos", 
            "text": "El control  mapbox-gl-inspect  permite ver todos los elementos\nde un VT y tambi\u00e9n permite pasar el cursor sobre los elementos para ver sus propiedades.  Agregar el c\u00f3digo de la librer\u00eda, e instanciar el control tras crear el mapa:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36 !DOCTYPE html  html  head \n     meta   charset = UTF-8 \n     meta   name = viewport   content = width=device-width, initial-scale=1 \n     title Mapa VT / title \n     link   rel = stylesheet   href = https://api.tiles.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.css   / \n     script   src = https://api.tiles.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.js / script       link   href = https://mapbox-gl-inspect.lukasmartinelli.ch/dist/mapbox-gl-inspect.css   rel = stylesheet   /       script   src = https://mapbox-gl-inspect.lukasmartinelli.ch/dist/mapbox-gl-inspect.min.js / script       style \n         html ,   body   { \n             margin :   0 ; \n             height :   100 % ; \n         } \n     / style  / head  body   id = map  script \n     var   map   =   new   mapboxgl . Map ({ \n         container :   map ,   // id del elemento HTML que contendr\u00e1 el mapa \n         style :   https://openmaptiles.github.io/osm-bright-gl-style/style-cdn.json ,   // Ubicaci\u00f3n del estilo \n         center :   [ 2.175 ,   41.39 ],   // Ubicaci\u00f3n inicial \n         zoom :   13 ,   // Zoom inicial \n         bearing :   - 45 ,   // \u00c1ngulo de rotaci\u00f3n inicial \n         hash :   true   // Permite ir guardando la posici\u00f3n del mapa en la URL \n     }); \n\n     // Agrega controles de navegaci\u00f3n (zoom, rotaci\u00f3n) al mapa: \n     map . addControl ( new   mapboxgl . NavigationControl ());       // Agregar el control de inspecci\u00f3n       map . addControl ( new   MapboxInspect ());  / script  / body  / html    Se recargar\u00e1 la p\u00e1gina en el navegador con un nuevo bot\u00f3n que permite la \"visi\u00f3n de rayos X\" sobre los datos.  \nResultado visor simple", 
            "title": "Inspector de datos"
        }, 
        {
            "location": "/2_visor_simple/#contenido-de-un-fichero-de-estilo", 
            "text": "Como vemos, el visor es muy sencillo, y parece que toda la \"magia\" se esconde en el fichero de estilo tras la URL https://openmaptiles.github.io/osm-bright-gl-style/style-cdn.json .  Si lo abrimos, es un objeto JSON bastante complejo, pero si nos fijamos en las propiedades de primer nivel, son pocas.\nLas principales:   1\n2\n3\n4\n5\n6\n7\n8 { \n   version :   8 , \n   name :   OSM Bright , \n   sprite :   https://openmaptiles.github.io/osm-bright-gl-style/sprite , \n   glyphs :   https://free.tilehosting.com/fonts/{fontstack}/{range}.pbf?key=RiS4gsgZPZqeeMlIyxFo , \n   sources :   { ... }, \n   layers :   [ ... ]  }     version  es obligatoria y siempre es 8.  name  es opcional pero conveniente, es una etiqueta para mostrar el nombre del estilo.   sprite  indica de d\u00f3nde obtener el conjunto de  iconos  necesarios para simbolizar.  glyphs : indica de d\u00f3nde obtener el conjunto de  tipograf\u00edas  necesarios para simbolizar.  sources : los or\u00edgenes de datos.  layers : las reglas de simbolizaci\u00f3n. El orden es importante: Se van dibujando de la primera (que queda por debajo)\na la \u00faltima (que queda por encima). As\u00ed, la primera regla suele ser el color de fondo del mapa, y las \u00faltimas suelen\nser la toponimia o los PoIs.   En los pr\u00f3ximos cap\u00edtulos veremos en detalle c\u00f3mo usar  sources ,  layers ,  sprites  y  glyphs .  Habitualmente tambi\u00e9n se usan otras propiedades para indicar la vista inicial del mapa. Por ejemplo:  1\n2\n3\n4\n5\n6\n7 { \n   ... \n   center :   [ 2.15 ,   41.39 ], \n   zoom :   12 , \n   bearing :   -45 , \n   pitch :   0  }     center : Coordenadas iniciales donde centrar el mapa [lon, lat]  zoom : Zoom inicial del mapa  bearing : Rotaci\u00f3n inicial del mapa (en grados)  pitch : Inclinaci\u00f3n inicial del mapa para verlo en perspectiva (de 0 a 60 grados)    Tip  La especificaci\u00f3n completa del fichero de estilo es parte de la  documentaci\u00f3n on-line de Mapbox GL\nJS .", 
            "title": "Contenido de un fichero de estilo"
        }, 
        {
            "location": "/3_tileserver_gl/", 
            "text": "C\u00f3mo servir teselas vectoriales\n\n\nInstalaci\u00f3n de TileServer GL\n\n\nTileServer GL\n es un servidor de mapas de c\u00f3digo abierto creado para teselas vectoriales, y\ncapaz de renderizar en teselas raster con MapBox GL Native engine en el lado del servidor.\n\n\nProporciona mapas para aplicaciones web y m\u00f3viles. Es compatibles con Mapbox GL JS, Android SDK, iOS SDK, Leaflet,\nOpenLayers, HighDPI/Retina, SIG a trav\u00e9s de WMTS, etc.\n\n\nSi se quiere servir teselas raster lo mejor es utilizar la versi\u00f3n de Docker ya que son necesarias algunas librer\u00edas\nnativas que pueden variar dependiendo de la plataforma, estas librer\u00edas sirven para renderizar las teselas vectoriales\nen teselas raster. Si \u00fanicamente se quiere servir teselas vectoriales se puede utilizar el TileServer GL Light,\nque no tiene ninguna dependencia nativa ya que est\u00e1 desarrollado en javascript.\n\n\nPara este taller utilizaremos la versi\u00f3n Light ya que serviremos s\u00f3lo teselas vectoriales.\n\n\nEs necesario tener instalado \nNode.js\n versi\u00f3n 6.\n\n\n\n\nWarning\n\n\ntileserver-gl-light NO se instalar\u00e1 correctamente si estamos usando una versi\u00f3n de Node.js superior a la 6.\nDebemos activar esta versi\u00f3n de node con el comando:\n\n\n1\n2\nnvm use \n6\n\nnode -v \n# Deber\u00eda devolver: 6.x.x\n\n\n\n\n\n\n\n\n\nUna vez comprobada la versi\u00f3n de node:\n\n\n1\n2\nnpm install -g tileserver-gl-light@2.3.1\ntileserver-gl-light -v \n# Deberia devolver: v2.3.1 \n\n\n\n\n\n\n\nArranque con la configuraci\u00f3n por defecto\n\n\nObtener datos de Barcelona\n\n\nCrear una carpeta llamada \ntileserver/data\n y copiar en ella el fichero `datos/barcelona.mbtiles:\n\n\n1\n2\nmkdir -p tileserver/data\ncp datos/barcelona.mbtiles tileserver/data\n\n\n\n\n\n\n\n\nTip\n\n\nEn la web de \nOpenMapTiles\n se pueden descargar datos de muchas\notras ciudades, pa\u00edses, e incluso el planeta entero. Es gratu\u00edto, aunque hay que registrarse y los datos\nno est\u00e1n del todo actualizados. \n\n\n\n\nAhora arrancaremos el servidor en el puerto \n8081\n (par\u00e1metro \n-p\n):\n\n\n1\n2\ncd\n tileserver\ntileserver-gl-light data/barcelona.mbtiles -p \n8081\n\n\n\n\n\n\n\nAbrir el navegador y escribir \nhttp://localhost:8081\n. Aparecer\u00e1 la p\u00e1gina del TileServer.\n\n\nDejar el terminal abierto con el servidor arrancado.\n\n\n\n\nTileServer GL Light\n\n\nModificar el visor de mapas\n\n\nModificaremos nuestro archivo \nindex.html\n para que el visor de mapas consuma las teselas vectoriales servidas por\n nuestro TileServer:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n!DOCTYPE html\n\n\nhtml\n\n\nhead\n\n    \nmeta\n \ncharset\n=\nUTF-8\n\n    \nmeta\n \nname\n=\nviewport\n \ncontent\n=\nwidth=device-width, initial-scale=1\n\n    \ntitle\nMapa VT\n/\ntitle\n\n    \nlink\n \nrel\n=\nstylesheet\n \nhref\n=\nhttps://api.tiles.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.css\n \n/\n\n    \nscript\n \nsrc\n=\nhttps://api.tiles.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.js\n/\nscript\n\n    \nlink\n \nhref\n=\nhttps://mapbox-gl-inspect.lukasmartinelli.ch/dist/mapbox-gl-inspect.css\n \nrel\n=\nstylesheet\n \n/\n\n    \nscript\n \nsrc\n=\nhttps://mapbox-gl-inspect.lukasmartinelli.ch/dist/mapbox-gl-inspect.min.js\n/\nscript\n\n    \nstyle\n\n        \nhtml\n,\n \nbody\n \n{\n\n            \nmargin\n:\n \n0\n;\n\n            \nheight\n:\n \n100\n%\n;\n\n        \n}\n\n    \n/\nstyle\n\n\n/\nhead\n\n\nbody\n \nid\n=\nmap\n\n\nscript\n\n    \nvar\n \nmap\n \n=\n \nnew\n \nmapboxgl\n.\nMap\n({\n\n        \ncontainer\n:\n \nmap\n,\n \n// id del elemento HTML que contendr\u00e1 el mapa\n\n\n        \nstyle\n:\n \nhttp://localhost:8081/styles/osm-bright/style.json\n,\n \n// Ubicaci\u00f3n del estilo\n\n\n        \ncenter\n:\n \n[\n2.175\n,\n \n41.39\n],\n \n// Ubicaci\u00f3n inicial\n\n        \nzoom\n:\n \n13\n,\n \n// Zoom inicial\n\n        \nbearing\n:\n \n-\n45\n,\n \n// \u00c1ngulo de rotaci\u00f3n inicial\n\n        \nhash\n:\n \ntrue\n \n// Permite ir guardando la posici\u00f3n del mapa en la URL\n\n    \n});\n\n\n    \n// Agrega controles de navegaci\u00f3n (zoom, rotaci\u00f3n) al mapa:\n\n    \nmap\n.\naddControl\n(\nnew\n \nmapboxgl\n.\nNavigationControl\n());\n\n\n    \n// Agregar el control de inspecci\u00f3n\n\n    \nmap\n.\naddControl\n(\nnew\n \nMapboxInspect\n());\n\n\n/\nscript\n\n\n/\nbody\n\n\n/\nhtml\n\n\n\n\n\n\n\nConfiguraci\u00f3n completa\n\n\nParemos el servidor y volvamos a arrancarlo, pero esta vez con la opci\u00f3n \n-V\n (verbose):\n\n\n1\n2\ncd\n tileserver\ntileserver-gl-light data/barcelona.mbtiles -p \n8081\n -V\n\n\n\n\n\n\nObservaremos que nos dice \"Automatically creating config file for barcelona.mbtiles\", y a continuaci\u00f3n nos muestra\nel fichero de configuraci\u00f3n que ha autogenerado, y que aproximadamente tendr\u00e1 este aspecto:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n{\n\n  \noptions\n:\n \n{\n\n    \npaths\n:\n \n{\n\n      \nroot\n:\n \n/home/user/.nvm/versions/node/v6.14.2/lib/node_modules/tileserver-gl-light/node_modules/tileserver-gl-styles\n,\n\n      \nfonts\n:\n \nfonts\n,\n\n      \nstyles\n:\n \nstyles\n,\n\n      \nmbtiles\n:\n \n/home/user/Desktop/taller-vt/tileserver/data\n\n    \n}\n\n  \n},\n\n  \nstyles\n:\n \n{\n\n    \nklokantech-basic\n:\n \n{\n\n      \nstyle\n:\n \nklokantech-basic/style.json\n,\n\n      \ntilejson\n:\n \n{\n\n        \nbounds\n:\n \n[\n-180\n,\n \n-85.0511\n,\n \n180\n,\n \n85.0511\n]\n\n      \n}\n\n    \n},\n\n    \nosm-bright\n:\n \n{\n\n      \nstyle\n:\n \nosm-bright/style.json\n,\n\n      \ntilejson\n:\n \n{\n\n        \nbounds\n:\n \n[\n-180\n,\n \n-85.0511\n,\n \n180\n,\n \n85.0511\n]\n\n      \n}\n\n    \n}\n\n  \n},\n\n  \ndata\n:\n \n{\n\n    \nv3\n:\n \n{\n\n      \nmbtiles\n:\n \nbarcelona.mbtiles\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nLa configuraci\u00f3n se divide en estos tres elementos:\n\n\n\n\noptions.paths\n: Rutas de donde obtener los diferentes recursos: \nmbtiles\n (datos), \nfonts\n (tambi\u00e9n llamados \nglyphs\n), y \nstyles\n.\n\n\nstyles\n: Ficheros de estilos y alguna informaci\u00f3n adicional para generar el fichero auxiliar TileJSON.\n\n\ndata\n: Origenes de datos. Apunta a los diferentes ficheros \n.mbtiles\n que queramos servir.\n\n\n\n\nCopiemos la configuraci\u00f3n que nos ha devuelto \ntileserver-gl-light\n en el fichero de configuraci\u00f3n \ntileserver/config.json\n.\n\n\n\n\nWarning\n\n\nAtenci\u00f3n a la ruta de \noptions.paths\n, que puede variar ligeramente entre estos apuntes y la ruta en vuestra m\u00e1quina,\ndependiendo de la versi\u00f3n exacta de node que teng\u00e1is instalada. Tened en cuenta esta discrepancia en la ruta para las\npr\u00f3ximas instrucciones. El resto de la configuraci\u00f3n deber\u00eda ser la misma. \n\n\n\n\nPor defecto \nTileserver GL\n viene con dos estilos incorporados (\nklokantech-basic\n y \nosm-bright\n) y cuatro tipograf\u00edas\n(\nOpen Sans\n en sus varintes \nRegular\n, \nItalic\n, \nBold\n y \nSemibold\n), que se esconden en la ruta profunda indicada en\n\noptions.paths.root\n.\n\n\nVamos a copiar estos recursos en nuestro directorio de trabajo:\n\n\n1\n2\n3\n4\nmkdir styles\nmkdir fonts\ncp -r /home/user/.nvm/versions/node/v6.14.2/lib/node_modules/tileserver-gl-light/node_modules/tileserver-gl-styles/styles styles\ncp -r /home/user/.nvm/versions/node/v6.14.2/lib/node_modules/tileserver-gl-light/node_modules/tileserver-gl-styles/fonts fonts\n\n\n\n\n\n\nComprobemos que en \n~/Desktop/taller-vt/tileserver\n tenemos tres directorios \ndata\n, \nfonts\n y \nstyles\n, y el fichero \nconfig.json\n.\n\n\nModifiquemos ahora el fichero \nconfig.json\n para apuntar a nuestros recursos:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n{\n\n  \noptions\n:\n \n{\n\n    \npaths\n:\n \n{\n\n\n      \nroot\n:\n \n,\n\n\n      \nfonts\n:\n \nfonts\n,\n\n\n      \nstyles\n:\n \nstyles\n,\n\n\n      \nmbtiles\n:\n \ndata\n\n\n    \n}\n\n  \n},\n\n  \nstyles\n:\n \n{\n\n    \nklokantech-basic\n:\n \n{\n\n      \nstyle\n:\n \nklokantech-basic/style.json\n,\n\n      \ntilejson\n:\n \n{\n\n\n        \nbounds\n:\n \n[\n1.898\n,\n \n41.246\n,\n \n2.312\n,\n \n41.533\n]\n\n\n      \n}\n\n    \n},\n\n    \nosm-bright\n:\n \n{\n\n      \nstyle\n:\n \nosm-bright/style.json\n,\n\n      \ntilejson\n:\n \n{\n\n\n        \nbounds\n:\n \n[\n1.898\n,\n \n41.246\n,\n \n2.312\n,\n \n41.533\n]\n\n\n      \n}\n\n    \n}\n\n  \n},\n\n  \ndata\n:\n \n{\n\n    \nv3\n:\n \n{\n\n      \nmbtiles\n:\n \nbarcelona.mbtiles\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nDe paso hemos modificado el BBOX de los datos de Barcelona, que no estaba bien ajustado.\n\n\nArrancamos tileserver de nuevo, sin indicar el fichero de datos:\n\n\n1\ntileserver-gl-light -p \n8081\n\n\n\n\n\n\n\nTileserver deber\u00e1 decir \"Using specified config file from config.json\". Si vamos a \nhttp://localhost:8081\n deber\u00edamos\nver lo mismo que antes, pero ahora podremos ir a\u00f1adiendo nuestros propios datasets, estilos, tipograf\u00edas e iconos al\nservidor.\n\n\nA\u00f1adiendo datos de edificios\n\n\nVamos a copiar un nuevo \n.mbtiles\n con informaci\u00f3n de edificios:\n\n\n1\ncp ../datos/buildings.mbtiles data/\n\n\n\n\n\n\nY lo vamos a a\u00f1adir al fichero \nconfig.json\n:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n{\n\n  \noptions\n:\n \n{\n\n    \npaths\n:\n \n{\n\n      \nroot\n:\n \n,\n\n      \nfonts\n:\n \nfonts\n,\n\n      \nstyles\n:\n \nstyles\n,\n\n      \nmbtiles\n:\n \ndata\n\n    \n}\n\n  \n},\n\n  \nstyles\n:\n \n{\n\n    \nklokantech-basic\n:\n \n{\n\n      \nstyle\n:\n \nklokantech-basic/style.json\n,\n\n      \ntilejson\n:\n \n{\n\n        \nbounds\n:\n \n[\n1.898\n,\n \n41.246\n,\n \n2.312\n,\n \n41.533\n]\n\n      \n}\n\n    \n},\n\n    \nosm-bright\n:\n \n{\n\n      \nstyle\n:\n \nosm-bright/style.json\n,\n\n      \ntilejson\n:\n \n{\n\n        \nbounds\n:\n \n[\n1.898\n,\n \n41.246\n,\n \n2.312\n,\n \n41.533\n]\n\n      \n}\n\n    \n}\n\n  \n},\n\n  \ndata\n:\n \n{\n\n    \nv3\n:\n \n{\n\n      \nmbtiles\n:\n \nbarcelona.mbtiles\n\n    \n},\n\n\n    \nbuildings\n:\n \n{\n\n\n      \nmbtiles\n:\n \nbuildings.mbtiles\n\n\n    \n}\n\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nParamos el servidor y arrancamos de nuevo. Recargando la p\u00e1gina \nhttp://localhost:8081\n veremos el nuevo dataset:\n\n\n\n\nHaciendo click en \"Preview\":\n\n\n\n\nEfectivamente, se trata de una capa con m\u00e1s de 500.000 construcciones de catastro, con la referencia de la parcela\ncatastral a la que pertenece cada construcci\u00f3n, y el n\u00famero de plantas para cada construcci\u00f3n. \n\n\n\n\nQuestion\n\n\n\u00bfPara qu\u00e9 sirve el \"TileJSON\" de un dataset?\n\n\nEn \u00faltima instancia, las teselas vectoriales se sirven en un servicio HTTP con una URL que acaba en \n/{z}/{x}/{y}.pbf\n.\n\n\nDe hecho, en el estilo de mapbox podemos indicar esta url directamente, as\u00ed:\n\n\n1\n2\n3\n4\n5\n6\n7\nsources\n:\n \n{\n\n    \n...\n\n    \nbuildings\n,\n \n{\n\n        \ntype\n:\n \nvector\n,\n\n        \ntiles\n:\n \n[\nhttp://localhost:8081/data/buildings/{z}/{x}/{y}.pbf\n]\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nAunque el m\u00e9todo preferido es apuntar a un TileJSON. Esta configuraci\u00f3n ser\u00eda equivalente a la anterior, pero m\u00e1s correcta:\n\n1\n2\n3\n4\n5\n6\n7\nsources\n:\n \n{\n\n    \n...\n\n    \nbuildings\n,\n \n{\n\n        \ntype\n:\n \nvector\n,\n\n        \nurl\n:\n \nhttp://localhost:8081/data/buildings.json\n\n    \n}\n\n\n}\n\n\n\n\n\n\nEl fichero TileJSON acaba teniendo una propiedad \"tiles\" que apunta al servicio XYZ, pero adem\u00e1s contiene otros\nmetadatos \u00fatiles para quien consume el dataset. Por ejemplo, el rango de niveles de zoom v\u00e1lidos para el dataset\n(\nminzoom\n, \nmaxzoom\n) y el bbox v\u00e1lido (\nbounds\n), lo que evita hacer peticiones fuera de rango al servidor, y\notros metadatos como las \"capas\" contenidas en cada Vector Tile, y los atributos de cada capa. Esto ayuda a funcionar\nal \nInspectorPlugin\n, y tambi\u00e9n nos da informaci\u00f3n a la hora de simbolizar la capa, ya que nos describe el esquema\nde los datos.\n\n\n\n\nA\u00f1adiendo los nuevos datos al visor\n\n\nPara visualizar los datos de edificios en \nbarcelona.html\n, usar el siguiente c\u00f3digo javascript:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\nscript\n\n    \nvar\n \nmap\n \n=\n \nnew\n \nmapboxgl\n.\nMap\n({\n\n        \ncontainer\n:\n \nmap\n,\n \n// id del elemento HTML que contendr\u00e1 el mapa\n\n\n        \nstyle\n:\n \nhttp://localhost:8081/styles/klokantech-basic/style.json\n,\n\n\n        \ncenter\n:\n \n[\n2.19224\n,\n \n41.38585\n],\n\n\n        \nzoom\n:\n \n15\n,\n\n\n        \nbearing\n:\n \n-\n45\n,\n\n\n        \npitch\n:\n \n60\n,\n\n\n        \nhash\n:\n \ntrue\n\n    \n});\n\n\n    \n// Agrega controles de navegaci\u00f3n (zoom, rotaci\u00f3n) al mapa:\n\n    \nmap\n.\naddControl\n(\nnew\n \nmapboxgl\n.\nNavigationControl\n());\n\n\n    \n// Agregar el control de inspecci\u00f3n\n\n    \nmap\n.\naddControl\n(\nnew\n \nMapboxInspect\n());\n\n\n\n    \nmap\n.\non\n(\nload\n,\n \nfunction\n()\n \n{\n\n\n        \nmap\n.\naddSource\n(\nbuildings\n,\n \n{\n\n\n            \ntype\n:\n \nvector\n,\n\n\n            \nurl\n:\n \nhttp://localhost:8081/data/buildings.json\n\n\n        \n});\n\n\n\n\n        \nmap\n.\naddLayer\n({\n\n\n            \nid\n:\n \nbuildings\n,\n\n\n            \nsource\n:\n \nbuildings\n,\n\n\n            \nsource-layer\n:\n \nbuildingpart\n,\n\n\n            \ntype\n:\n \nfill\n,\n\n\n            \npaint\n:\n \n{\n\n\n                \nfill-opacity\n:\n \n0.75\n,\n\n\n                \nfill-color\n:\n \n#E9DFCD\n,\n\n\n                \nfill-outline-color\n:\n \n#000\n\n\n            \n}\n\n\n        \n});\n\n\n    \n});\n\n\n/\nscript\n\n\n\n\n\n\n\n\n\nIncluso podemos usar una regla de simbolizaci\u00f3n de extrusi\u00f3n para verlos en 3D:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\nmap\n.\non\n(\nload\n,\n \nfunction\n()\n \n{\n\n    \nmap\n.\naddSource\n(\nbuildings\n,\n \n{\n\n        \ntype\n:\n \nvector\n,\n\n        \nurl\n:\n \nhttp://localhost:8081/data/buildings.json\n\n    \n});\n\n\n    \nmap\n.\naddLayer\n({\n\n        \nid\n:\n \nbuildings\n,\n\n        \nsource\n:\n \nbuildings\n,\n\n        \nsource-layer\n:\n \nbuildingpart\n,\n\n\n        \ntype\n:\n \nfill-extrusion\n,\n\n\n        \npaint\n:\n \n{\n\n\n            \nfill-extrusion-opacity\n:\n \n0.75\n,\n\n\n            \nfill-extrusion-color\n:\n \n#E9DFCD\n,\n\n\n            \nfill-extrusion-height\n:\n \n[\n*\n,\n \n3\n,\n \n[\nget\n,\n \nfloors\n]]\n\n\n        \n}\n\n\n    \n});\n\n\n});\n\n\n\n\n\n\n\nEn la regla de simbolizaci\u00f3n hemos utilizado como altura de la extrusi\u00f3n el n\u00famero de plantas multiplicado por 3.", 
            "title": "3. C\u00f3mo servirlas"
        }, 
        {
            "location": "/3_tileserver_gl/#como-servir-teselas-vectoriales", 
            "text": "", 
            "title": "C\u00f3mo servir teselas vectoriales"
        }, 
        {
            "location": "/3_tileserver_gl/#instalacion-de-tileserver-gl", 
            "text": "TileServer GL  es un servidor de mapas de c\u00f3digo abierto creado para teselas vectoriales, y\ncapaz de renderizar en teselas raster con MapBox GL Native engine en el lado del servidor.  Proporciona mapas para aplicaciones web y m\u00f3viles. Es compatibles con Mapbox GL JS, Android SDK, iOS SDK, Leaflet,\nOpenLayers, HighDPI/Retina, SIG a trav\u00e9s de WMTS, etc.  Si se quiere servir teselas raster lo mejor es utilizar la versi\u00f3n de Docker ya que son necesarias algunas librer\u00edas\nnativas que pueden variar dependiendo de la plataforma, estas librer\u00edas sirven para renderizar las teselas vectoriales\nen teselas raster. Si \u00fanicamente se quiere servir teselas vectoriales se puede utilizar el TileServer GL Light,\nque no tiene ninguna dependencia nativa ya que est\u00e1 desarrollado en javascript.  Para este taller utilizaremos la versi\u00f3n Light ya que serviremos s\u00f3lo teselas vectoriales.  Es necesario tener instalado  Node.js  versi\u00f3n 6.   Warning  tileserver-gl-light NO se instalar\u00e1 correctamente si estamos usando una versi\u00f3n de Node.js superior a la 6.\nDebemos activar esta versi\u00f3n de node con el comando:  1\n2 nvm use  6 \nnode -v  # Deber\u00eda devolver: 6.x.x     Una vez comprobada la versi\u00f3n de node:  1\n2 npm install -g tileserver-gl-light@2.3.1\ntileserver-gl-light -v  # Deberia devolver: v2.3.1", 
            "title": "Instalaci\u00f3n de TileServer GL"
        }, 
        {
            "location": "/3_tileserver_gl/#arranque-con-la-configuracion-por-defecto", 
            "text": "", 
            "title": "Arranque con la configuraci\u00f3n por defecto"
        }, 
        {
            "location": "/3_tileserver_gl/#obtener-datos-de-barcelona", 
            "text": "Crear una carpeta llamada  tileserver/data  y copiar en ella el fichero `datos/barcelona.mbtiles:  1\n2 mkdir -p tileserver/data\ncp datos/barcelona.mbtiles tileserver/data    Tip  En la web de  OpenMapTiles  se pueden descargar datos de muchas\notras ciudades, pa\u00edses, e incluso el planeta entero. Es gratu\u00edto, aunque hay que registrarse y los datos\nno est\u00e1n del todo actualizados.    Ahora arrancaremos el servidor en el puerto  8081  (par\u00e1metro  -p ):  1\n2 cd  tileserver\ntileserver-gl-light data/barcelona.mbtiles -p  8081    Abrir el navegador y escribir  http://localhost:8081 . Aparecer\u00e1 la p\u00e1gina del TileServer.  Dejar el terminal abierto con el servidor arrancado.   TileServer GL Light", 
            "title": "Obtener datos de Barcelona"
        }, 
        {
            "location": "/3_tileserver_gl/#modificar-el-visor-de-mapas", 
            "text": "Modificaremos nuestro archivo  index.html  para que el visor de mapas consuma las teselas vectoriales servidas por\n nuestro TileServer:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36 !DOCTYPE html  html  head \n     meta   charset = UTF-8 \n     meta   name = viewport   content = width=device-width, initial-scale=1 \n     title Mapa VT / title \n     link   rel = stylesheet   href = https://api.tiles.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.css   / \n     script   src = https://api.tiles.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.js / script \n     link   href = https://mapbox-gl-inspect.lukasmartinelli.ch/dist/mapbox-gl-inspect.css   rel = stylesheet   / \n     script   src = https://mapbox-gl-inspect.lukasmartinelli.ch/dist/mapbox-gl-inspect.min.js / script \n     style \n         html ,   body   { \n             margin :   0 ; \n             height :   100 % ; \n         } \n     / style  / head  body   id = map  script \n     var   map   =   new   mapboxgl . Map ({ \n         container :   map ,   // id del elemento HTML que contendr\u00e1 el mapa           style :   http://localhost:8081/styles/osm-bright/style.json ,   // Ubicaci\u00f3n del estilo           center :   [ 2.175 ,   41.39 ],   // Ubicaci\u00f3n inicial \n         zoom :   13 ,   // Zoom inicial \n         bearing :   - 45 ,   // \u00c1ngulo de rotaci\u00f3n inicial \n         hash :   true   // Permite ir guardando la posici\u00f3n del mapa en la URL \n     }); \n\n     // Agrega controles de navegaci\u00f3n (zoom, rotaci\u00f3n) al mapa: \n     map . addControl ( new   mapboxgl . NavigationControl ()); \n\n     // Agregar el control de inspecci\u00f3n \n     map . addControl ( new   MapboxInspect ());  / script  / body  / html", 
            "title": "Modificar el visor de mapas"
        }, 
        {
            "location": "/3_tileserver_gl/#configuracion-completa", 
            "text": "Paremos el servidor y volvamos a arrancarlo, pero esta vez con la opci\u00f3n  -V  (verbose):  1\n2 cd  tileserver\ntileserver-gl-light data/barcelona.mbtiles -p  8081  -V   Observaremos que nos dice \"Automatically creating config file for barcelona.mbtiles\", y a continuaci\u00f3n nos muestra\nel fichero de configuraci\u00f3n que ha autogenerado, y que aproximadamente tendr\u00e1 este aspecto:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29 { \n   options :   { \n     paths :   { \n       root :   /home/user/.nvm/versions/node/v6.14.2/lib/node_modules/tileserver-gl-light/node_modules/tileserver-gl-styles , \n       fonts :   fonts , \n       styles :   styles , \n       mbtiles :   /home/user/Desktop/taller-vt/tileserver/data \n     } \n   }, \n   styles :   { \n     klokantech-basic :   { \n       style :   klokantech-basic/style.json , \n       tilejson :   { \n         bounds :   [ -180 ,   -85.0511 ,   180 ,   85.0511 ] \n       } \n     }, \n     osm-bright :   { \n       style :   osm-bright/style.json , \n       tilejson :   { \n         bounds :   [ -180 ,   -85.0511 ,   180 ,   85.0511 ] \n       } \n     } \n   }, \n   data :   { \n     v3 :   { \n       mbtiles :   barcelona.mbtiles \n     } \n   }  }    La configuraci\u00f3n se divide en estos tres elementos:   options.paths : Rutas de donde obtener los diferentes recursos:  mbtiles  (datos),  fonts  (tambi\u00e9n llamados  glyphs ), y  styles .  styles : Ficheros de estilos y alguna informaci\u00f3n adicional para generar el fichero auxiliar TileJSON.  data : Origenes de datos. Apunta a los diferentes ficheros  .mbtiles  que queramos servir.   Copiemos la configuraci\u00f3n que nos ha devuelto  tileserver-gl-light  en el fichero de configuraci\u00f3n  tileserver/config.json .   Warning  Atenci\u00f3n a la ruta de  options.paths , que puede variar ligeramente entre estos apuntes y la ruta en vuestra m\u00e1quina,\ndependiendo de la versi\u00f3n exacta de node que teng\u00e1is instalada. Tened en cuenta esta discrepancia en la ruta para las\npr\u00f3ximas instrucciones. El resto de la configuraci\u00f3n deber\u00eda ser la misma.    Por defecto  Tileserver GL  viene con dos estilos incorporados ( klokantech-basic  y  osm-bright ) y cuatro tipograf\u00edas\n( Open Sans  en sus varintes  Regular ,  Italic ,  Bold  y  Semibold ), que se esconden en la ruta profunda indicada en options.paths.root .  Vamos a copiar estos recursos en nuestro directorio de trabajo:  1\n2\n3\n4 mkdir styles\nmkdir fonts\ncp -r /home/user/.nvm/versions/node/v6.14.2/lib/node_modules/tileserver-gl-light/node_modules/tileserver-gl-styles/styles styles\ncp -r /home/user/.nvm/versions/node/v6.14.2/lib/node_modules/tileserver-gl-light/node_modules/tileserver-gl-styles/fonts fonts   Comprobemos que en  ~/Desktop/taller-vt/tileserver  tenemos tres directorios  data ,  fonts  y  styles , y el fichero  config.json .  Modifiquemos ahora el fichero  config.json  para apuntar a nuestros recursos:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29 { \n   options :   { \n     paths :   {         root :   ,         fonts :   fonts ,         styles :   styles ,         mbtiles :   data       } \n   }, \n   styles :   { \n     klokantech-basic :   { \n       style :   klokantech-basic/style.json , \n       tilejson :   {           bounds :   [ 1.898 ,   41.246 ,   2.312 ,   41.533 ]         } \n     }, \n     osm-bright :   { \n       style :   osm-bright/style.json , \n       tilejson :   {           bounds :   [ 1.898 ,   41.246 ,   2.312 ,   41.533 ]         } \n     } \n   }, \n   data :   { \n     v3 :   { \n       mbtiles :   barcelona.mbtiles \n     } \n   }  }    De paso hemos modificado el BBOX de los datos de Barcelona, que no estaba bien ajustado.  Arrancamos tileserver de nuevo, sin indicar el fichero de datos:  1 tileserver-gl-light -p  8081    Tileserver deber\u00e1 decir \"Using specified config file from config.json\". Si vamos a  http://localhost:8081  deber\u00edamos\nver lo mismo que antes, pero ahora podremos ir a\u00f1adiendo nuestros propios datasets, estilos, tipograf\u00edas e iconos al\nservidor.", 
            "title": "Configuraci\u00f3n completa"
        }, 
        {
            "location": "/3_tileserver_gl/#anadiendo-datos-de-edificios", 
            "text": "Vamos a copiar un nuevo  .mbtiles  con informaci\u00f3n de edificios:  1 cp ../datos/buildings.mbtiles data/   Y lo vamos a a\u00f1adir al fichero  config.json :   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32 { \n   options :   { \n     paths :   { \n       root :   , \n       fonts :   fonts , \n       styles :   styles , \n       mbtiles :   data \n     } \n   }, \n   styles :   { \n     klokantech-basic :   { \n       style :   klokantech-basic/style.json , \n       tilejson :   { \n         bounds :   [ 1.898 ,   41.246 ,   2.312 ,   41.533 ] \n       } \n     }, \n     osm-bright :   { \n       style :   osm-bright/style.json , \n       tilejson :   { \n         bounds :   [ 1.898 ,   41.246 ,   2.312 ,   41.533 ] \n       } \n     } \n   }, \n   data :   { \n     v3 :   { \n       mbtiles :   barcelona.mbtiles \n     },       buildings :   {         mbtiles :   buildings.mbtiles       }     }  }    Paramos el servidor y arrancamos de nuevo. Recargando la p\u00e1gina  http://localhost:8081  veremos el nuevo dataset:   Haciendo click en \"Preview\":   Efectivamente, se trata de una capa con m\u00e1s de 500.000 construcciones de catastro, con la referencia de la parcela\ncatastral a la que pertenece cada construcci\u00f3n, y el n\u00famero de plantas para cada construcci\u00f3n.    Question  \u00bfPara qu\u00e9 sirve el \"TileJSON\" de un dataset?  En \u00faltima instancia, las teselas vectoriales se sirven en un servicio HTTP con una URL que acaba en  /{z}/{x}/{y}.pbf .  De hecho, en el estilo de mapbox podemos indicar esta url directamente, as\u00ed:  1\n2\n3\n4\n5\n6\n7 sources :   { \n     ... \n     buildings ,   { \n         type :   vector , \n         tiles :   [ http://localhost:8081/data/buildings/{z}/{x}/{y}.pbf ] \n     }  }    Aunque el m\u00e9todo preferido es apuntar a un TileJSON. Esta configuraci\u00f3n ser\u00eda equivalente a la anterior, pero m\u00e1s correcta: 1\n2\n3\n4\n5\n6\n7 sources :   { \n     ... \n     buildings ,   { \n         type :   vector , \n         url :   http://localhost:8081/data/buildings.json \n     }  }    El fichero TileJSON acaba teniendo una propiedad \"tiles\" que apunta al servicio XYZ, pero adem\u00e1s contiene otros\nmetadatos \u00fatiles para quien consume el dataset. Por ejemplo, el rango de niveles de zoom v\u00e1lidos para el dataset\n( minzoom ,  maxzoom ) y el bbox v\u00e1lido ( bounds ), lo que evita hacer peticiones fuera de rango al servidor, y\notros metadatos como las \"capas\" contenidas en cada Vector Tile, y los atributos de cada capa. Esto ayuda a funcionar\nal  InspectorPlugin , y tambi\u00e9n nos da informaci\u00f3n a la hora de simbolizar la capa, ya que nos describe el esquema\nde los datos.", 
            "title": "A\u00f1adiendo datos de edificios"
        }, 
        {
            "location": "/3_tileserver_gl/#anadiendo-los-nuevos-datos-al-visor", 
            "text": "Para visualizar los datos de edificios en  barcelona.html , usar el siguiente c\u00f3digo javascript:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36 script \n     var   map   =   new   mapboxgl . Map ({ \n         container :   map ,   // id del elemento HTML que contendr\u00e1 el mapa           style :   http://localhost:8081/styles/klokantech-basic/style.json ,           center :   [ 2.19224 ,   41.38585 ],           zoom :   15 ,           bearing :   - 45 ,           pitch :   60 ,           hash :   true \n     }); \n\n     // Agrega controles de navegaci\u00f3n (zoom, rotaci\u00f3n) al mapa: \n     map . addControl ( new   mapboxgl . NavigationControl ()); \n\n     // Agregar el control de inspecci\u00f3n \n     map . addControl ( new   MapboxInspect ());       map . on ( load ,   function ()   {           map . addSource ( buildings ,   {               type :   vector ,               url :   http://localhost:8081/data/buildings.json           });            map . addLayer ({               id :   buildings ,               source :   buildings ,               source-layer :   buildingpart ,               type :   fill ,               paint :   {                   fill-opacity :   0.75 ,                   fill-color :   #E9DFCD ,                   fill-outline-color :   #000               }           });       });  / script     Incluso podemos usar una regla de simbolizaci\u00f3n de extrusi\u00f3n para verlos en 3D:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18 map . on ( load ,   function ()   { \n     map . addSource ( buildings ,   { \n         type :   vector , \n         url :   http://localhost:8081/data/buildings.json \n     }); \n\n     map . addLayer ({ \n         id :   buildings , \n         source :   buildings , \n         source-layer :   buildingpart ,           type :   fill-extrusion ,           paint :   {               fill-extrusion-opacity :   0.75 ,               fill-extrusion-color :   #E9DFCD ,               fill-extrusion-height :   [ * ,   3 ,   [ get ,   floors ]]           }       });  });    En la regla de simbolizaci\u00f3n hemos utilizado como altura de la extrusi\u00f3n el n\u00famero de plantas multiplicado por 3.", 
            "title": "A\u00f1adiendo los nuevos datos al visor"
        }, 
        {
            "location": "/4_tippecanoe/", 
            "text": "C\u00f3mo crear teselas vectoriales\n\n\nLos datos de Natural Earth\n\n\nEn el apartado de descargas de \nNatural Earth\n hay varios conjuntos de datos\nen formato Shapefile, seg\u00fan la escala. En el taller trabajaremos con un subconjunto de los datos de la escala 1:10M\n(1:10.000.000). Para ahorrarnos la transformaci\u00f3n de Shapefile a GeoJSON, utilizaremos los datos procedentes de\n\nhttps://github.com/nvkelso/natural-earth-vector/\n.\n\n\nEn concreto usaremos las siguientes capas:\n\n\n\n\nCultural\n\n\nAdmin 0 \u2013 Countries (247 pa\u00edses en el mundo. Groenlandia separada de Dinamarca)\n\n\nPopulated Places (Puntos de ciudades y pueblos)\n\n\nRoads (Carreteras principales)\n\n\nRailroads (V\u00edas de Trenes)\n\n\nAirports (Aeropuertos)\n\n\n\n\n\n\nPhysical\n\n\nCoastline (L\u00ednea de costa que incluyen islas principales)\n\n\nLand (Pol\u00edgonos terrestres que incluyen islas principales)\n\n\nOcean (Oceano)\n\n\nRivers + lake centerlines (Rios en \u00fanica l\u00ednea que incluyen l\u00edneas centrales de lagos)\n\n\nLakes + Reservoirs (Lagos naturales y artificiales)\n\n\n\n\n\n\n\n\nNosotros descargaremos las 10 capas de un zip y las descomprimiremos en \ntaller-vt/datos/naturalearth\n:\n\n\n1\n2\n3\ncd\n datos\nwget https://geoinquiets.github.io/taller-vt/downloads/naturalearth.zip\nunzip naturalearth.zip \n\n\n\n\n\n\nTippecanoe\n\n\nTippecanoe\n es la herramienta que permite crear teselas vectoriales de\ngrandes colecciones de elementos en formato GeoJSON.\n\n\nEl objetivo de Tippecanoe es permitir una visi\u00f3n de sus datos independiente de la escala, de modo que en cualquier\nnivel, desde el mundo entero hasta un solo edificio, se pueda apreciar la densidad y la textura de los datos, en\nlugar de una simplificaci\u00f3n geom\u00e9trica, que puede eliminar v\u00e9rtices importantes que cambien la apariencia de los datos\nen su versi\u00f3n simplificada.\n\n\nAlgunos ejemplos:\n\n\n\n\nTeniendo todo el callejero de OpenStreetMap, la vista general devolver\u00e1 algo que se parece a\n\"Todas las calles\" en lugar de algo que parece un atlas de carreteras interestatal.\n\n\nTeniendo todas las plantas de edificios de una ciudad, en la vista general donde los edificios individuales ya no\nsean perceptibles, a\u00fan deber\u00edas poder ver la extensi\u00f3n y variedad del desarrollo en cada vecindario,\nno solo para los edificios m\u00e1s voluminosos.\n\n\n\n\nEsto hace que la calidad de los resultados de Tippecanoe sea muy superior a otras alternativas, que utilizan algoritmos\nde simplificaci\u00f3n m\u00e1s convencionales, motivo por el cual lo recomendamos en este taller.\n\n\nAdem\u00e1s, es sorprendentemente r\u00e1pido procesando los datos.\n\n\nCreando el fichero mbtiles\n\n\nVamos a crear un fichero mbtiles llamado \nnatural_earth.mbtiles\n que contendr\u00e1 nuestras 10 capas. \n\n\nPara crear el mbtiles utilizaremos las siguientes \nopciones del Tippecanoe\n:\n\n\n\n\n-o nombre.mbtiles\n: nombre del archivo de salida.\n\n\n-zg\n: Estima un maxzoom razonable basado en la resoluci\u00f3n de los datos.\n\n\n--drop-densest-as-needed\n: Si una tesela es demasiado pesada, intenta reducirla a menos de 500 KB reduciendo su detalle.\n\n\n-L nombre:archivo.json\n: permite definir nombres de capa para cada archivo individual.\n\n\n\n\nPara generar el archivo mbtiles escribiremos lo siguiente en el terminal:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\ncd\n naturalearth\ntippecanoe -o natural_earth.mbtiles -zg --drop-densest-as-needed \n\\\n\n  -L ocean:ne_10m_ocean.geojson \n\\\n\n  -L land:ne_10m_land.geojson \n\\\n\n  -L admin:ne_10m_admin_0_countries.geojson \n\\\n\n  -L coastline:ne_10m_coastline.geojson \n\\\n\n  -L lakes:ne_10m_lakes.geojson \n\\\n\n  -L rivers:ne_10m_rivers_lake_centerlines.geojson \n\\\n\n  -L rail:ne_10m_railroads.geojson \n\\\n\n  -L roads:ne_10m_roads.geojson \n\\\n\n  -L cities:ne_10m_populated_places.geojson \n\\\n\n  -L airports:ne_10m_airports.geojson\n\n\n\n\n\n\nPublicando el mbtiles\n\n\nA\u00f1adiremos el mbtiles a \nTileserver GL\n igual que hicimos con los edificios de Barcelona:\n\n\n1\n2\nmv natural_earth.mbtiles ../../tileserver/data\ncd ../../tileserver\n\n\n\n\n\n\nEditamos \nconfig.json\n y a\u00f1adimos la nueva capa:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n{\n\n  \n...\n\n  \ndata\n:\n \n{\n\n    \nv3\n:\n \n{\n\n      \nmbtiles\n:\n \nbarcelona.mbtiles\n\n    \n},\n\n    \nbuildings\n:\n \n{\n\n      \nmbtiles\n:\n \nbuildings.mbtiles\n\n    \n},\n\n    \nnatural_earth\n:\n \n{\n\n      \nmbtiles\n:\n \nnatural_earth.mbtiles\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nAbrir el navegador y escribir \nhttp://localhost:8081\n y comprobar que aparece la p\u00e1gina del TileServer con nuestro mbtiles:\n\n\n\n\nHacer click en el bot\u00f3n de \nInspect\n y comprobar que en el mapa aparecen todas las capas agregadas al mbtiles:\n\n\n\n\nAs\u00ed pues, una tesela vectorial contiene varias \"capas\" internamente. En una regla de simbolizaci\u00f3n, deber\u00e1 indicarse\ntanto origen de datos (\n\"source\": \"natural_earth\"\n), como la capa dentro de la tesela (\n\"source_layer\": \"roads\"\n).", 
            "title": "4. C\u00f3mo crearlas"
        }, 
        {
            "location": "/4_tippecanoe/#como-crear-teselas-vectoriales", 
            "text": "", 
            "title": "C\u00f3mo crear teselas vectoriales"
        }, 
        {
            "location": "/4_tippecanoe/#los-datos-de-natural-earth", 
            "text": "En el apartado de descargas de  Natural Earth  hay varios conjuntos de datos\nen formato Shapefile, seg\u00fan la escala. En el taller trabajaremos con un subconjunto de los datos de la escala 1:10M\n(1:10.000.000). Para ahorrarnos la transformaci\u00f3n de Shapefile a GeoJSON, utilizaremos los datos procedentes de https://github.com/nvkelso/natural-earth-vector/ .  En concreto usaremos las siguientes capas:   Cultural  Admin 0 \u2013 Countries (247 pa\u00edses en el mundo. Groenlandia separada de Dinamarca)  Populated Places (Puntos de ciudades y pueblos)  Roads (Carreteras principales)  Railroads (V\u00edas de Trenes)  Airports (Aeropuertos)    Physical  Coastline (L\u00ednea de costa que incluyen islas principales)  Land (Pol\u00edgonos terrestres que incluyen islas principales)  Ocean (Oceano)  Rivers + lake centerlines (Rios en \u00fanica l\u00ednea que incluyen l\u00edneas centrales de lagos)  Lakes + Reservoirs (Lagos naturales y artificiales)     Nosotros descargaremos las 10 capas de un zip y las descomprimiremos en  taller-vt/datos/naturalearth :  1\n2\n3 cd  datos\nwget https://geoinquiets.github.io/taller-vt/downloads/naturalearth.zip\nunzip naturalearth.zip", 
            "title": "Los datos de Natural Earth"
        }, 
        {
            "location": "/4_tippecanoe/#tippecanoe", 
            "text": "Tippecanoe  es la herramienta que permite crear teselas vectoriales de\ngrandes colecciones de elementos en formato GeoJSON.  El objetivo de Tippecanoe es permitir una visi\u00f3n de sus datos independiente de la escala, de modo que en cualquier\nnivel, desde el mundo entero hasta un solo edificio, se pueda apreciar la densidad y la textura de los datos, en\nlugar de una simplificaci\u00f3n geom\u00e9trica, que puede eliminar v\u00e9rtices importantes que cambien la apariencia de los datos\nen su versi\u00f3n simplificada.  Algunos ejemplos:   Teniendo todo el callejero de OpenStreetMap, la vista general devolver\u00e1 algo que se parece a\n\"Todas las calles\" en lugar de algo que parece un atlas de carreteras interestatal.  Teniendo todas las plantas de edificios de una ciudad, en la vista general donde los edificios individuales ya no\nsean perceptibles, a\u00fan deber\u00edas poder ver la extensi\u00f3n y variedad del desarrollo en cada vecindario,\nno solo para los edificios m\u00e1s voluminosos.   Esto hace que la calidad de los resultados de Tippecanoe sea muy superior a otras alternativas, que utilizan algoritmos\nde simplificaci\u00f3n m\u00e1s convencionales, motivo por el cual lo recomendamos en este taller.  Adem\u00e1s, es sorprendentemente r\u00e1pido procesando los datos.", 
            "title": "Tippecanoe"
        }, 
        {
            "location": "/4_tippecanoe/#creando-el-fichero-mbtiles", 
            "text": "Vamos a crear un fichero mbtiles llamado  natural_earth.mbtiles  que contendr\u00e1 nuestras 10 capas.   Para crear el mbtiles utilizaremos las siguientes  opciones del Tippecanoe :   -o nombre.mbtiles : nombre del archivo de salida.  -zg : Estima un maxzoom razonable basado en la resoluci\u00f3n de los datos.  --drop-densest-as-needed : Si una tesela es demasiado pesada, intenta reducirla a menos de 500 KB reduciendo su detalle.  -L nombre:archivo.json : permite definir nombres de capa para cada archivo individual.   Para generar el archivo mbtiles escribiremos lo siguiente en el terminal:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 cd  naturalearth\ntippecanoe -o natural_earth.mbtiles -zg --drop-densest-as-needed  \\ \n  -L ocean:ne_10m_ocean.geojson  \\ \n  -L land:ne_10m_land.geojson  \\ \n  -L admin:ne_10m_admin_0_countries.geojson  \\ \n  -L coastline:ne_10m_coastline.geojson  \\ \n  -L lakes:ne_10m_lakes.geojson  \\ \n  -L rivers:ne_10m_rivers_lake_centerlines.geojson  \\ \n  -L rail:ne_10m_railroads.geojson  \\ \n  -L roads:ne_10m_roads.geojson  \\ \n  -L cities:ne_10m_populated_places.geojson  \\ \n  -L airports:ne_10m_airports.geojson", 
            "title": "Creando el fichero mbtiles"
        }, 
        {
            "location": "/4_tippecanoe/#publicando-el-mbtiles", 
            "text": "A\u00f1adiremos el mbtiles a  Tileserver GL  igual que hicimos con los edificios de Barcelona:  1\n2 mv natural_earth.mbtiles ../../tileserver/data\ncd ../../tileserver   Editamos  config.json  y a\u00f1adimos la nueva capa:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14 { \n   ... \n   data :   { \n     v3 :   { \n       mbtiles :   barcelona.mbtiles \n     }, \n     buildings :   { \n       mbtiles :   buildings.mbtiles \n     }, \n     natural_earth :   { \n       mbtiles :   natural_earth.mbtiles \n     } \n   }  }    Abrir el navegador y escribir  http://localhost:8081  y comprobar que aparece la p\u00e1gina del TileServer con nuestro mbtiles:   Hacer click en el bot\u00f3n de  Inspect  y comprobar que en el mapa aparecen todas las capas agregadas al mbtiles:   As\u00ed pues, una tesela vectorial contiene varias \"capas\" internamente. En una regla de simbolizaci\u00f3n, deber\u00e1 indicarse\ntanto origen de datos ( \"source\": \"natural_earth\" ), como la capa dentro de la tesela ( \"source_layer\": \"roads\" ).", 
            "title": "Publicando el mbtiles"
        }, 
        {
            "location": "/5_sprites_glyphs/", 
            "text": "Sprites y Glyphs\n\n\nSprites\n\n\n\n\nDefinici\u00f3n\n\n\nUn \nsprite\n es una imagen individual que contiene todos los iconos incluidos en un estilo. Al combinar muchas\nim\u00e1genes peque\u00f1as en una sola imagen (sprite), se puede reducir el n\u00famero de solicitudes necesarias para recuperar\ntodas las im\u00e1genes, mejorar el rendimiento y hacer que el mapa sea m\u00e1s r\u00e1pido.\n\n\nLos Sprites pueden tener un tama\u00f1o m\u00e1ximo de 1024x1024 p\u00edxeles (o 2048x2048 para pantallas con alta DPI).\nCada sprite viene acompa\u00f1ado de un archivo JSON donde se define el nombre de cada icono, y su posici\u00f3n y tama\u00f1o\npara saber c\u00f3mo \"recortarlo\" de la imagen com\u00fan.\n\n\nM\u00e1s informaci\u00f3n en sobre sprites \nhttps://www.mapbox.com/help/define-sprite/\n\n\n\n\nCada uno de los iconos contenidos en un sprite se puede usar como textura para el fondo del mapa, patr\u00f3n de relleno para\nun pol\u00edgono, patr\u00f3n de dibujo para una l\u00ednea, o una imagen de icono (s\u00edmbolo puntual).\n\n\nLa propiedad \nsprite\n de un estilo apunta a una URL \nincompleta\n, a partir de la cual se pueden encontrar los diferentes\nficheros (sprites y json complementario).\n\n\nPor ejemplo, si en el \nstyle.json\n se indica:\n\n\n1\n2\n3\n4\n{\n\n    \n...\n\n    \nsprite\n:\n \nhttp://localhost:8081/styles/osm-bright/sprite\n\n\n}\n\n\n\n\n\n\n\nEn realidad dicha URL no existe. Pero s\u00ed existen los siguientes recursos (a\u00f1adiendo \n.png\n, \n.json\n, \n@2x.png\n y \n@2x.json\n respectivamente):\n\n\n\n\nhttp://localhost:8081/styles/osm-bright/sprite.png\n Sprite a resoluci\u00f3n convencional\n\n\nhttp://localhost:8081/styles/osm-bright/sprite.json\n JSON que define cada icono dentro del sprite\n\n\nhttp://localhost:8081/styles/osm-bright/sprite@2x.png\n Sprite a resoluci\u00f3n doble (para pantallas Retina)\n\n\nhttp://localhost:8081/styles/osm-bright/sprite@2x.json\n JSON que define cada icono dentro del sprite de resoluci\u00f3n doble\n\n\n\n\nEjemplo de sprite:\n\n\n\n\nUno de los elementos definidos en el JSON:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n{\n\n    \n...\n\n    \nairport_11\n:\n \n{\n\n        \nheight\n:\n \n17\n,\n\n        \nwidth\n:\n \n17\n,\n\n        \nx\n:\n \n17\n,\n\n        \ny\n:\n \n0\n,\n\n        \npixelRatio\n:\n \n1\n\n    \n},\n\n    \n....\n\n\n}\n\n\n\n\n\n\n\nC\u00f3mo crear tus propios sprites\n\n\nPara generar los sprites a partir de im\u00e1genes individuales hay que crear los cuatro archivos. Esto se podr\u00eda hacer\nmanualmente con un editor de texto, un editor de im\u00e1genes y mucha paciencia, pero afortunadamente existen herramientas\nque lo automatizan. \n\n\nLos sprites convencionales para la web difieren de los de Mapbox, ya que utilizan una imagen compuesta \npng\n y un archivo\n\ncss\n con las reglas de simbolizaci\u00f3n para su aprovechamiento en p\u00e1ginas web. Mapbox GL, en cambio, necesita el fichero\n\njson\n, no un CSS. \n\n\nPara generar los sprites y sus json a partir de una colecci\u00f3n de im\u00e1genes en formato SVG, se recomienda el uso de la\nlibrer\u00eda de Mapbox \nspritezero-cli\n, de la siguiente manera:\n\n\n1\n2\n3\n4\ncd\n datos\nnpm install -g @mapbox/spritezero-cli\nspritezero sprite iconos-maki-svg\nspritezero --retina sprite@2x iconos-maki-svg\n\n\n\n\n\n\nUna vez generados, los movemos al directorio donde residir\u00e1 el estilo que los use (en nuestro caso, \nnatural-earth\n):\n\n\n1\n2\nmkdir ../tileserver/styles/natural-earth\nmv sprite* ../tileserver/styles/natural-earth\n\n\n\n\n\n\nGlyphs\n\n\nEn la propiedad \nglyphs\n se indica una plantilla de URL para cargar tipograf\u00edas en formato PBF, que se usar\u00e1n para\ndibujar etiquetas en el mapa. Por ejemplo:\n\n\n1\n2\n3\n4\n{\n\n    \n...\n\n    \nglyphs\n:\n \nhttp://localhost:8081/fonts/{fontstack}/{range}.pbf\n\n\n}\n\n\n\n\n\n\n\nEsta plantilla de URL debe incluir dos tokens:\n\n\n\n\n{fontstack}\n es el nombre de la tipograf\u00eda. Por ejemplo \nOpen Sans Bold\n.\n\n\n{range}\n es un rango de 256 puntos de c\u00f3digo Unicode (es decir, un subconjunto de letras o s\u00edmbolos). En funci\u00f3n del texto a mostrar, el visor solicitar\u00e1 los rangos necesarios. El primero es \n0-255\n.\n\n\n\n\nUna petici\u00f3n real tendr\u00eda la forma:\n\n\n\n\nhttp://localhost:8081/fonts/Open%20Sans%20Bold/0-255.pbf\n\n\n\n\nUn glyph contiene una derivada de la tipograf\u00eda binaria que permite escalarla sin el pixelado, y ser\u00eda una imagen en\n escala de grises con este aspecto:\n\n\n\n\nC\u00f3mo crear tus propios glyphs\n\n\nDescargar el proyecto de github \nopenmaptiles/fonts\n\n\n1\n2\n3\n4\n5\n6\ncd\n ~/Desktop/taller-vt/\nwget https://github.com/openmaptiles/fonts/archive/master.zip\nunzip master.zip\n\ncd\n fonts-master\nnpm install\nnode generate.js\n\n\n\n\n\n\nAl cabo de un rato, podemos ver los resultados en el directorio \n_output\n.\n\n\nSi no queremos generar una tipograf\u00eda determinada, basta con borrar el directorio que la contiene.\nDel mismo modo podemos a\u00f1adir tipograf\u00edas a\u00f1adiendo nuevos directorios y copiando dentro las tipograf\u00edas en\nformato TTF. Por ejemplo, para generar \"Comic Sans\":\n\n\n1\n2\n3\nrm -rf metropolis noto-sans open-sans pt-sans roboto\ncp -r ../datos/comic-sans-ms .\nnode generate.js\n\n\n\n\n\n\nEl directorio \n_output\n no se borra entre ejecuciones, con lo que habremos conservado todas las fuentes anteriores,\nadem\u00e1s de la reci\u00e9n generada \"Comic Sans\".\n\n\nFinalmente, copiaremos el contenido de \n_output\n al directorio \ntileserver/fonts\n:\n\n\n1\ncp -r _output/* ../tileserver/fonts\n\n\n\n\n\n\nPara que el tileserver publique estos recursos, hay que a\u00f1adir una propiedad a \ntileserver/config.json\n:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n{\n\n  \noptions\n:\n \n{\n\n    \npaths\n:\n \n{\n\n      \nroot\n:\n \n,\n\n      \nfonts\n:\n \nfonts\n,\n\n      \nstyles\n:\n \nstyles\n,\n\n      \nmbtiles\n:\n \ndata\n\n    \n},\n\n\n    \nserveAllFonts\n:\n \ntrue\n\n\n  \n},\n\n  \n...\n\n\n}\n\n\n\n\n\n\n\nReiniciando el tileserver para que cargue las nuevas tipograf\u00edas, podemos ver la lista de\nlas tipograf\u00edas disponibles en la direcci\u00f3n \nhttp://localhost:8081/fonts.json\n\n\nEjercicio extra: Generar una tipograf\u00eda a partir de un conjunto de iconos en SVG\n\n\nSi queremos disponer de una colecci\u00f3n de iconos monocrom\u00e1ticos de forma m\u00e1s flexible que usando\nsprites, los podemos convertir en una tipograf\u00eda. Esto permitir\u00e1 aplicar las t\u00e9cnicas de las etiquetas de texto a\nnuestros s\u00edmbolos, como escalarlos sin apreciar pixelado, cambiar su color de base, a\u00f1adir un halo, etc. \n\n\nPara transformar un conjunto de iconos SVG en una fuente se pueden utilizar diferentes programas.\nAqui un listado de algunas webs que permiten generar fuentes:\n\n\n\n\nhttps://icomoon.io\n\n\nhttp://fontello.com/\n\n\nhttps://glyphter.com/\n\n\nhttp://fontastic.me/\n\n\n\n\nTambi\u00e9n podemos generar una fuente propia utilizando el repositorio \nhttps://github.com/gencat/ICGC-fonticon-generator\n,\nde la siguiente manera:\n\n\n1\n2\n3\n4\n5\ngit clone https://github.com/gencat/ICGC-fonticon-generator\nnpm i -g gulp\n\ncd\n ICGC-fonticon-generator/\nnpm install\ngulp iconfont\n\n\n\n\n\n\nUna vez generada la fuente, que encontraremos en \niconfont/Geostart-Regular.ttf\n, podemos generar los glyphs como se ha\nexplicado en el apartado anterior, y a\u00f1adirlos al tileserver.", 
            "title": "5. Sprites y Glyphs"
        }, 
        {
            "location": "/5_sprites_glyphs/#sprites-y-glyphs", 
            "text": "", 
            "title": "Sprites y Glyphs"
        }, 
        {
            "location": "/5_sprites_glyphs/#sprites", 
            "text": "Definici\u00f3n  Un  sprite  es una imagen individual que contiene todos los iconos incluidos en un estilo. Al combinar muchas\nim\u00e1genes peque\u00f1as en una sola imagen (sprite), se puede reducir el n\u00famero de solicitudes necesarias para recuperar\ntodas las im\u00e1genes, mejorar el rendimiento y hacer que el mapa sea m\u00e1s r\u00e1pido.  Los Sprites pueden tener un tama\u00f1o m\u00e1ximo de 1024x1024 p\u00edxeles (o 2048x2048 para pantallas con alta DPI).\nCada sprite viene acompa\u00f1ado de un archivo JSON donde se define el nombre de cada icono, y su posici\u00f3n y tama\u00f1o\npara saber c\u00f3mo \"recortarlo\" de la imagen com\u00fan.  M\u00e1s informaci\u00f3n en sobre sprites  https://www.mapbox.com/help/define-sprite/   Cada uno de los iconos contenidos en un sprite se puede usar como textura para el fondo del mapa, patr\u00f3n de relleno para\nun pol\u00edgono, patr\u00f3n de dibujo para una l\u00ednea, o una imagen de icono (s\u00edmbolo puntual).  La propiedad  sprite  de un estilo apunta a una URL  incompleta , a partir de la cual se pueden encontrar los diferentes\nficheros (sprites y json complementario).  Por ejemplo, si en el  style.json  se indica:  1\n2\n3\n4 { \n     ... \n     sprite :   http://localhost:8081/styles/osm-bright/sprite  }    En realidad dicha URL no existe. Pero s\u00ed existen los siguientes recursos (a\u00f1adiendo  .png ,  .json ,  @2x.png  y  @2x.json  respectivamente):   http://localhost:8081/styles/osm-bright/sprite.png  Sprite a resoluci\u00f3n convencional  http://localhost:8081/styles/osm-bright/sprite.json  JSON que define cada icono dentro del sprite  http://localhost:8081/styles/osm-bright/sprite@2x.png  Sprite a resoluci\u00f3n doble (para pantallas Retina)  http://localhost:8081/styles/osm-bright/sprite@2x.json  JSON que define cada icono dentro del sprite de resoluci\u00f3n doble   Ejemplo de sprite:   Uno de los elementos definidos en el JSON:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11 { \n     ... \n     airport_11 :   { \n         height :   17 , \n         width :   17 , \n         x :   17 , \n         y :   0 , \n         pixelRatio :   1 \n     }, \n     ....  }", 
            "title": "Sprites"
        }, 
        {
            "location": "/5_sprites_glyphs/#como-crear-tus-propios-sprites", 
            "text": "Para generar los sprites a partir de im\u00e1genes individuales hay que crear los cuatro archivos. Esto se podr\u00eda hacer\nmanualmente con un editor de texto, un editor de im\u00e1genes y mucha paciencia, pero afortunadamente existen herramientas\nque lo automatizan.   Los sprites convencionales para la web difieren de los de Mapbox, ya que utilizan una imagen compuesta  png  y un archivo css  con las reglas de simbolizaci\u00f3n para su aprovechamiento en p\u00e1ginas web. Mapbox GL, en cambio, necesita el fichero json , no un CSS.   Para generar los sprites y sus json a partir de una colecci\u00f3n de im\u00e1genes en formato SVG, se recomienda el uso de la\nlibrer\u00eda de Mapbox  spritezero-cli , de la siguiente manera:  1\n2\n3\n4 cd  datos\nnpm install -g @mapbox/spritezero-cli\nspritezero sprite iconos-maki-svg\nspritezero --retina sprite@2x iconos-maki-svg   Una vez generados, los movemos al directorio donde residir\u00e1 el estilo que los use (en nuestro caso,  natural-earth ):  1\n2 mkdir ../tileserver/styles/natural-earth\nmv sprite* ../tileserver/styles/natural-earth", 
            "title": "C\u00f3mo crear tus propios sprites"
        }, 
        {
            "location": "/5_sprites_glyphs/#glyphs", 
            "text": "En la propiedad  glyphs  se indica una plantilla de URL para cargar tipograf\u00edas en formato PBF, que se usar\u00e1n para\ndibujar etiquetas en el mapa. Por ejemplo:  1\n2\n3\n4 { \n     ... \n     glyphs :   http://localhost:8081/fonts/{fontstack}/{range}.pbf  }    Esta plantilla de URL debe incluir dos tokens:   {fontstack}  es el nombre de la tipograf\u00eda. Por ejemplo  Open Sans Bold .  {range}  es un rango de 256 puntos de c\u00f3digo Unicode (es decir, un subconjunto de letras o s\u00edmbolos). En funci\u00f3n del texto a mostrar, el visor solicitar\u00e1 los rangos necesarios. El primero es  0-255 .   Una petici\u00f3n real tendr\u00eda la forma:   http://localhost:8081/fonts/Open%20Sans%20Bold/0-255.pbf   Un glyph contiene una derivada de la tipograf\u00eda binaria que permite escalarla sin el pixelado, y ser\u00eda una imagen en\n escala de grises con este aspecto:", 
            "title": "Glyphs"
        }, 
        {
            "location": "/5_sprites_glyphs/#como-crear-tus-propios-glyphs", 
            "text": "Descargar el proyecto de github  openmaptiles/fonts  1\n2\n3\n4\n5\n6 cd  ~/Desktop/taller-vt/\nwget https://github.com/openmaptiles/fonts/archive/master.zip\nunzip master.zip cd  fonts-master\nnpm install\nnode generate.js   Al cabo de un rato, podemos ver los resultados en el directorio  _output .  Si no queremos generar una tipograf\u00eda determinada, basta con borrar el directorio que la contiene.\nDel mismo modo podemos a\u00f1adir tipograf\u00edas a\u00f1adiendo nuevos directorios y copiando dentro las tipograf\u00edas en\nformato TTF. Por ejemplo, para generar \"Comic Sans\":  1\n2\n3 rm -rf metropolis noto-sans open-sans pt-sans roboto\ncp -r ../datos/comic-sans-ms .\nnode generate.js   El directorio  _output  no se borra entre ejecuciones, con lo que habremos conservado todas las fuentes anteriores,\nadem\u00e1s de la reci\u00e9n generada \"Comic Sans\".  Finalmente, copiaremos el contenido de  _output  al directorio  tileserver/fonts :  1 cp -r _output/* ../tileserver/fonts   Para que el tileserver publique estos recursos, hay que a\u00f1adir una propiedad a  tileserver/config.json :   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 { \n   options :   { \n     paths :   { \n       root :   , \n       fonts :   fonts , \n       styles :   styles , \n       mbtiles :   data \n     },       serveAllFonts :   true     }, \n   ...  }    Reiniciando el tileserver para que cargue las nuevas tipograf\u00edas, podemos ver la lista de\nlas tipograf\u00edas disponibles en la direcci\u00f3n  http://localhost:8081/fonts.json", 
            "title": "C\u00f3mo crear tus propios glyphs"
        }, 
        {
            "location": "/5_sprites_glyphs/#ejercicio-extra-generar-una-tipografia-a-partir-de-un-conjunto-de-iconos-en-svg", 
            "text": "Si queremos disponer de una colecci\u00f3n de iconos monocrom\u00e1ticos de forma m\u00e1s flexible que usando\nsprites, los podemos convertir en una tipograf\u00eda. Esto permitir\u00e1 aplicar las t\u00e9cnicas de las etiquetas de texto a\nnuestros s\u00edmbolos, como escalarlos sin apreciar pixelado, cambiar su color de base, a\u00f1adir un halo, etc.   Para transformar un conjunto de iconos SVG en una fuente se pueden utilizar diferentes programas.\nAqui un listado de algunas webs que permiten generar fuentes:   https://icomoon.io  http://fontello.com/  https://glyphter.com/  http://fontastic.me/   Tambi\u00e9n podemos generar una fuente propia utilizando el repositorio  https://github.com/gencat/ICGC-fonticon-generator ,\nde la siguiente manera:  1\n2\n3\n4\n5 git clone https://github.com/gencat/ICGC-fonticon-generator\nnpm i -g gulp cd  ICGC-fonticon-generator/\nnpm install\ngulp iconfont   Una vez generada la fuente, que encontraremos en  iconfont/Geostart-Regular.ttf , podemos generar los glyphs como se ha\nexplicado en el apartado anterior, y a\u00f1adirlos al tileserver.", 
            "title": "Ejercicio extra: Generar una tipograf\u00eda a partir de un conjunto de iconos en SVG"
        }, 
        {
            "location": "/6_estilos/", 
            "text": "C\u00f3mo simbolizar teselas vectoriales\n\n\nMaputnik\n\n\nEs un editor visual gratuito y abierto para estilos Mapbox GL dirigidos tanto a desarrolladores\ncomo a dise\u00f1adores de mapas.\n\n\nSe puede utilizar en l\u00ednea en \nMaputnik editor\n o se puede\nhacer una instalaci\u00f3n local.\n\n\nInstalaci\u00f3n\n\n\nSe puede descargar la \u00faltima versi\u00f3n de la \np\u00e1gina de releases\n.\nEn nuestro caso, la tenemos ya descargada en \n~/Desktop/taller-vt/maputnik\n.\n\n\nPara arrancar la versi\u00f3n local:\n\n\n1\n2\ncd\n ~/Desktop/taller-vt/maputnik\nlive-server --port\n=\n8082\n\n\n\n\n\n\n\nAbrir Maputnik en \nhttp://localhost:8082\n\n\n\n\nComenzar un estilo nuevo\n\n\nEn la barra de men\u00fa seleccionamos la opci\u00f3n \nOpen\n.\nDel apartado \nGallery Styles\n, seleccionamos \nEmpty Style\n.\n\n\nAgregar un origen de datos (Source)\n\n\nEn la barra de men\u00fa seleccionamos la opci\u00f3n \nSource\n.\nEn la parte inferior del di\u00e1logo est\u00e1 la secci\u00f3n: \nAdd New Source\n.\n\n\n\n\n\n\nComo \nSource ID\n ponemos \nnaturalearth\n.\n\n\nComo \nSource Type\n seleccionamos \nVector (TileJSON URL)\n.\n\n\nComo \nTileJSON URL\n seleccionamos \nhttp://localhost:8081/data/natural_earth.json\n\n\n\n\nTambi\u00e9n se podr\u00eda usar como \nSource Type\n un \nVector (XYZ URL)\n, en cuyo caso tambi\u00e9n hay que\nindicar el rango de zooms en que los datos son v\u00e1lidos.\n\n\nAgregar sprite y glyphs\n\n\nEn la barra de men\u00fa seleccionamos \nStyle Settings\n:\n\n\n\n\n\n\nName\n: Nombre del estilo. En nuestro caso pondremos \nNatural Earth\n.\n\n\nSprite URL\n: Usaremos el sprite de uno de los estilos que tenemos publicados en tileserver \nhttp://localhost:8081/styles/osm-bright/sprite\n\n\nGlyphs URL\n: Accederemos a las tipograf\u00edas publicadas en nuestro Tileserver \nhttp://localhost:8081/fonts/{fontstack}/{range}.pbf\n\n\n\n\nSimbolizaci\u00f3n b\u00e1sica\n\n\nPresionamos el bot\u00f3n de \nAdd Layer\n: \n\n\n\n\nFondo\n\n\nA\u00f1adimos una primera capa de fondo:\n\n\n\n\nID\n: identificador \u00fanico de la capa. Pondremos \nfondo\n.\n\n\nType\n: tipo de capa. Seleccionar la opci\u00f3n de \nBackground\n.\n\n\n\n\nSeleccionamos el color en \nPaint properties\n =\n \nColor\n: \"#50A8E7\".\n\n\nEl fondo del mapa pasa a un gris claro.\n\n\nOc\u00e9anos\n\n\nA\u00f1adimos ahora los oc\u00e9anos: \n\n\n\n\nID\n: identificador \u00fanico de la capa. Pondremos \noceanos\n.\n\n\nType\n: tipo de capa. Seleccionar la opci\u00f3n de \nFill\n ya que la capa es de tipo pol\u00edgono.\n\n\nSource\n: identificador del origen de datos. En nuestro caso pondremos \nnaturalearth\n.\n\n\nSource Layer\n: identificador de la capa dentro del origen de datos. Pondremos \nocean\n.\n\n\n\n\nAparecer\u00e1n los oc\u00e9anos de color negro.\n\n\nSimbolizamos la capa seleccionando un color RGB en \nPaint properties\n =\n \nColor\n: \"#50A8E7\".\n\n\nEn el apartado inferior del panel de propiedades de la capa, vamos viendo la definici\u00f3n tal\ncomo se guardar\u00e1 en el fichero json de estilo:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n{\n\n  \nid\n:\n \noceanos\n,\n\n  \ntype\n:\n \nfill\n,\n\n  \nsource\n:\n \nnaturalearth\n,\n\n  \nsource-layer\n:\n \nocean\n,\n\n  \npaint\n:\n \n{\n\n    \nfill-color\n:\n \n#50A8E7\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nMaputnik no es m\u00e1s que un asistente gr\u00e1fico para generar el fichero \nstyle.json\n. \n\n\nResto de capas b\u00e1sicas\n\n\nEl resto de capas se puede simbolizar procediendo de la misma manera: \n\n\n\n\n\n\n\n\nid\n\n\ntype\n\n\nsource-layer\n\n\ncolor\n\n\notras propiedades \"paint\"\n\n\n\n\n\n\n\n\n\n\nfondo\n\n\nBackground\n\n\n--\n\n\n#F8F4F0\n\n\n--\n\n\n\n\n\n\noceanos\n\n\nFill\n\n\nocean\n\n\n#A0C8F0\n\n\n--\n\n\n\n\n\n\ntierra\n\n\nFill\n\n\nland\n\n\n#E6C7C7\n\n\n--\n\n\n\n\n\n\ncosta\n\n\nLine\n\n\ncoastline\n\n\n#4793E8\n\n\n--\n\n\n\n\n\n\nrios\n\n\nLine\n\n\nrivers\n\n\n#4793E8\n\n\n--\n\n\n\n\n\n\nlagos\n\n\nFill\n\n\nlakes\n\n\n#A0C8F0\n\n\n\"stroke-color\": \"#4793E8\"\n\n\n\n\n\n\nferrocarril\n\n\nLine\n\n\nrail\n\n\n#707070\n\n\n--\n\n\n\n\n\n\ncarreteras\n\n\nLine\n\n\nroads\n\n\n#BF5757\n\n\n--\n\n\n\n\n\n\n\n\n\n\nFiltrar los datos a mostrar en una capa\n\n\nVamos a eliminar las rutas de ferry que se muestran como carreteras.\n\n\nHay dos maneras de definir un filtro en un estilo MapboxGL:\n1. \nFilters\n: La forma cl\u00e1sica, que implementa Maputnik: \nhttps://www.mapbox.com/mapbox-gl-js/style-spec/#other-filter\n\n2. \nDecision Expressions\n: La nueva forma, m\u00e1s potente, pero que Maputnik no implementa: \nhttps://www.mapbox.com/mapbox-gl-js/style-spec/#expressions-decision\n\n\nEn Maputnik, seleccionando la capa \ncarreteras\n, apartado \nFilter\n: Presionamos el bot\u00f3n \nAdd filter\n.\nLa condici\u00f3n ser\u00e1:\n\n\n1\n    featurecla == Road\n\n\n\n\n\n\n\n\nComprobar que desaparecen las l\u00edneas de Ferry en el mapa.\n\n\n\n\nTip\n\n\nUsa el \nInspect Mode\n integrado en Maputnik para explorar los diferentes campos de una capa y sus posibles valores.\n\n\n\n\nEjercicio extra\n\n\nCrea una nueva capa \"ferrys\" y aplica el filtro contrario para mostrar s\u00f3lo las rutas de ferry.\nInvestiga la propiedad \nDasharray\n para darle un aspecto de l\u00ednea discontinua a las rutas.\n\n\n\n\nEtiquetar una capa\n\n\n\n\n\n\nAgregar la capa de ciudades. Presionar el bot\u00f3n de \nAdd Layer\n y rellenar el formulario con\nla siguiente informaci\u00f3n:\n\n\n\n\nID\n: \nciudades\n\n\nType\n: \nSymbol\n, utilizado para mostrar entidades puntuales (iconos y etiquetas)\n\n\nSource\n: \nnaturalearth\n\n\nSource Layer\n: \ncities\n\n\n\n\n\n\n\n\nEn el apartado \nText layout properties\n:\n\n\n\n\nEn la propiedad \nField\n escribir \n{NAME}\n (el nombre del campo a mostrar, entre llaves).\n\n\nEn la propiedad \nFont\n, escribir \nComic Sans\n, tipograf\u00eda que hemos generado y publicado en el apartado anterior (nota: el taller sobre c\u00f3mo evitar hacer mapas feos es esta tarde).\n\n\n\n\n\n\n\n\nEstilizar las etiquetas. En el apartado de \nText paint properties\n:\n Para los textos podemos definir un Halo para que el teto destaque mejor en nuestro mapa.\n\n\n\n\n\n\nUtilizar un icono para simbolizar nuestra capa\n\n\n\n\n\n\nAgregar la capa de aeropuertos. Presionar el bot\u00f3n de \nAdd Layer\n y rellenar el formulario con\nla siguiente informaci\u00f3n:\n\n\n\n\nID\n: \naeropuertos\n\n\nType\n: \nSymbol\n, utilizado para mostrar entidades puntuales (iconos y etiquetas)\n\n\nSource\n: \nnaturalearth\n\n\nSource Layer\n: \nairports\n\n\n\n\n\n\n\n\nEn el apartado de \nIcon layout properties\n:\n\n\n\n\nEn la propiedad \nImage\n, escribir \nairport_11\n. Este nombre debe coincidir con alguna imagen definida en el sprite.\n\n\n\n\n\n\n\n\nComprobar que aparecen los aeropuertos en el mapa.\n\n\n\n\n\n\n\n\nTip\n\n\nEstos son los iconos del sprite del estilo (\nosm-bright\n) que estamos utilizando:\n\nhttps://github.com/openmaptiles/osm-bright-gl-style/tree/master/icons\n\n\n\n\nExportar el estilo creado\n\n\nSeleccionar la opci\u00f3n \nExport\n, y luego el boton de \nDownload\n para descargar el estilo en nuestro ordenador.\nDescargamos el archivo, lo renombramos a \nstyle.json\n y lo movemos a la carpeta \ntileserver/styles/natural-earth/\n,\ndonde ya hab\u00edamos copiado los sprites generados en el apartado anterior.\n\n\nHabr\u00e1 que editar el fichero de configuraci\u00f3n de tileserver \ntileserver/config.json\n para a\u00f1adir el estilo: \n\n\n1\n2\n3\n4\n5\n6\n7\n{\n\n  \nstyles\n:\n \n{\n\n    \nnatural-earth\n:\n \n{\n\n      \nstyle\n:\n \nnatural-earth/style.json\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nReiniciar tileserver y comprobar que ofrece el nuevo estilo de visualizaci\u00f3n.\n\n\nEdici\u00f3n manual del estilo\n\n\nVamos a dejar Maputnik a un lado y vamos a editar el estilo json a mano.\n\n\nCrear un visor para el nuevo estilo\n\n\nLo primero ser\u00e1 crear un visor para los datos y estilo de Natural Earth partiendo del visor de Barcelona.\nTambi\u00e9n usaremos una copia local del estilo porque ser\u00e1 m\u00e1s f\u00e1cil ir viendo los cambios. Cada vez que guardemos en disco una\nmodificaci\u00f3n del fichero de estilo, podremos recargar directamente la p\u00e1gina en el navegador para reflejar los cambios.\n\n\n\n\nCopiar el archivo \nvisor/barcelona.html\n en \nvisor/naturalearth.html\n\n\nAdem\u00e1s, hacer una copia de \ntileserver/styles/natural-earth/style.json\n en \nvisor/natural-earth-style.json\n.\n\n\n\n\nEditaremos \nvisor/naturalearth.html\n y en la parte de \nscript\n dejaremos s\u00f3lo este c\u00f3digo:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\nvar\n \nmap\n \n=\n \nnew\n \nmapboxgl\n.\nMap\n({\n\n    \ncontainer\n:\n \nmap\n,\n\n    \nstyle\n:\n \nnatural-earth-style.json\n,\n\n    \ncenter\n:\n \n[\n1.5\n,\n \n41\n],\n\n    \nzoom\n:\n \n5\n,\n\n    \nhash\n:\n \ntrue\n\n\n});\n\n\n\nmap\n.\naddControl\n(\nnew\n \nmapboxgl\n.\nNavigationControl\n());\n\n\nmap\n.\naddControl\n(\nnew\n \nMapboxInspect\n());\n\n\n\n\n\n\n\nAbriendo en el navegador \nhttp://127.0.0.1:8080/naturalearth.html\n deber\u00eda verse:\n\n\n\n\nEstilo avanzado basado en expresiones\n\n\nEl estilo basado en datos permite estilizar los datos en funci\u00f3n del valor de sus propiedades.\nPor ejemplo, cambiar el radio de un c\u00edrculo o el color de un pol\u00edgono en funci\u00f3n de un valor\nnum\u00e9rico, o usar l\u00f3gica condicional para crear etiquetas multiling\u00fces.\n\n\nLas \nexpresiones de Mapbox GL\n se\npueden usar en cualquier propiedad de tipo \nlayout\n, \npaint\n o \nfilter\n de una \nlayer\n.\n\n\nGracias a las expresiones, una regla de simbolizaci\u00f3n determinada puede calcularse como el resultado de\nun c\u00e1lculo donde intervienen los valores de una o m\u00e1s propiedades de una \nfeature\n. Pueden\nusarse operaciones l\u00f3gicas, matem\u00e1ticas, de generaci\u00f3n de color, interpolaciones, etc.\n\n\nEstilo basado en valores concretos de una propiedad\n\n\nAbrir el fichero \nnatural-earth-style.json\n y localizar el layer con id \ncarreteras\n.\n\n\nVamos a asignar un color distinto en funci\u00f3n del valor de la propiedad \ntype\n.\nPara ello usaremos la expresi\u00f3n \nMatch\n,\nque asigna a cada valor de entrada un valor de salida distinto (en nuestro caso, un color para\ncada tipo de carretera):\n\n\n1\n2\n3\n4\n5\n6\n[\nmatch\n, \npropiedad\n,\n    \nvalorentrada_1\n, \nsalida_1\n,\n    \nentrada_2\n, \nsalida_2\n,\n    ...,\n    \nsalida_por_defecto\n\n]\n\n\n\n\n\n\nPara obtener el valor de la propiedad de una feature se usa la expresi\u00f3n Get: \n[\"get\", \nnombre_propiedad\n]\n.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n{\n\n    \nid\n:\n \ncarreteras\n,\n\n    \ntype\n:\n \nline\n,\n\n    \nsource\n:\n \nnaturalearth\n,\n\n    \nsource-layer\n:\n \nroads\n,\n\n    \nfilter\n:\n \n[\nall\n,\n \n[\n==\n,\n \nfeaturecla\n,\n \nRoad\n]],\n\n    \npaint\n:\n \n{\n\n        \nline-color\n:\n \n[\n\n\n            \nmatch\n,\n \n[\nget\n,\n \ntype\n],\n\n\n            \nMajor Highway\n,\n     \nrgba(20, 52, 232, 1)\n,\n\n\n            \nSecondary Highway\n,\n \nrgba(206, 32, 79, 1)\n,\n\n\n            \nRoad\n,\n              \nrgba(49, 137, 52, 1)\n,\n\n\n            \nrgba(255, 204, 0, 1)\n\n\n        \n],\n\n        \nline-width\n:\n \n2\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nEstilo basado en el nivel del zoom\n\n\nLocalizar el layer con id \nciudades\n.\n\n\nVamos a cambiar el tama\u00f1o del texto seg\u00fan el nivel de zoom del mapa, y de la propiedad \nSCALERANK\n del dato.\n\n\nUsaremos la expresi\u00f3n \nCase\n, que tiene\nesta forma:\n\n\n1\n2\n3\n4\n5\n6\n[\ncase\n,\n    \ncondicion_1\n, \nsalida_1\n,\n    \ncondicion_2\n, \nsalida_2\n,\n    ...,\n    \nsalida_por_defecto\n\n]\n\n\n\n\n\n\nEn nuestro caso la usaremos para decir cosas como:\n\n\n\n\nSi \"SCALERANK\" es menor que 2, aplica un tama\u00f1o de letra 20,\n\n\nSi \"SCALERANK\" est\u00e1 entre 3 y 5, aplica un tama\u00f1o de letra 14,\n\n\nEn cualquier otro caso, aplica un tama\u00f1o de letra 10\n\n\n\n\nQue quedar\u00eda expresado as\u00ed:\n\n\n1\n2\n3\n4\n5\n6\n[\n\n  \ncase\n,\n\n  \n[\n=\n,\n \n[\nnumber\n,[\nget\n,\n \nSCALERANK\n]],\n \n2\n],\n \n20\n,\n\n  \n[\n=\n,\n \n[\nnumber\n,[\nget\n,\n \nSCALERANK\n]],\n \n5\n],\n \n14\n,\n\n  \n10\n\n\n]\n\n\n\n\n\n\n\nEl operador \n\"number\"\n se usa para convertir el valor \nSCALERANK\n a un tipo num\u00e9rico.\n\n\nY la combinaremos con la expresi\u00f3n \nStep\n, que tiene\nesta forma:\n\n\n1\n2\n3\n4\n5\n6\n[\nstep\n,\n    \nentrada\n, \nsalida_inicial\n,\n    \numbral_1\n, \nsalida_1\n,\n    \numbral_2\n, \nsalida_2\n,\n    ...\n]\n\n\n\n\n\n\nEn nuestro caso la podemos usar para decir cosas como:\n\n\n\n\nUsa un tama\u00f1o de letra 18 para zooms por debajo de 5.\n\n\nUsa un tama\u00f1o de letra 20 entre el zoom 5 y 8.\n\n\nUsa un tama\u00f1o de letra 24 para zooms mayores que 8.\n\n\n\n\nQue quedar\u00eda:\n\n\n1\n2\n3\n4\n5\n[\nstep\n,\n\n    \n[\nzoom\n],\n \n18\n,\n\n    \n5\n,\n \n20\n,\n\n    \n8\n,\n \n24\n\n\n]\n\n\n\n\n\n\n\nObviamente podemos combinar ambas expresiones, de forma que la salida para cada nivel de zoom no sea un tama\u00f1o de\n letra concreto, sino que dependa de \"SCALERANK\". Y nos queda el siguiente monstruo para el Layer:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n{\n\n    \nid\n:\n \nciudades\n,\n\n    \ntype\n:\n \nsymbol\n,\n\n    \nsource\n:\n \nnaturalearth\n,\n\n    \nsource-layer\n:\n \ncities\n,\n\n    \nlayout\n:\n \n{\n\n        \ntext-field\n:\n \n{NAME}\n,\n\n        \ntext-anchor\n:\n \nbottom\n,\n\n        \ntext-offset\n:\n \n[\n0\n,\n \n-1\n],\n\n        \ntext-size\n:\n \n[\n\n            \nstep\n,\n \n[\nzoom\n],\n\n            \n[\n\n              \ncase\n,\n\n              \n[\n,\n \n[\nnumber\n,\n \n[\nget\n,\n \nSCALERANK\n]],\n \n3\n],\n \n18\n,\n\n              \n0\n\n            \n],\n\n            \n5\n,\n \n[\ncase\n,\n\n                  \n[\n=\n,\n \n[\nnumber\n,[\nget\n,\n \nSCALERANK\n]],\n \n2\n],\n \n20\n,\n\n                  \n[\n=\n,\n \n[\nnumber\n,[\nget\n,\n \nSCALERANK\n]],\n \n5\n],\n \n14\n,\n\n                  \n10\n\n               \n],\n\n            \n8\n,\n \n[\ncase\n,\n\n                  \n[\n=\n,\n \n[\nnumber\n,[\nget\n,\n \nSCALERANK\n]],\n \n2\n],\n \n24\n,\n\n                  \n[\n=\n,\n \n[\nnumber\n,[\nget\n,\n \nSCALERANK\n]],\n \n5\n],\n \n18\n,\n\n                  \n14\n\n               \n]\n\n        \n]\n\n    \n},\n\n    \npaint\n:\n \n{\n\n        \ntext-halo-color\n:\n \nrgba(253, 253, 253, 1)\n,\n\n        \ntext-color\n:\n \nrgba(16, 16, 16, 1)\n,\n\n        \ntext-halo-width\n:\n \n1.5\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nComo se puede observar, las expresiones son tan potentes como dif\u00edciles de escribir bien a la primera.\n\n\nEstilo basado en una propiedad\n\n\nVamos a crear un nuevo \nlayer\n llamado \nciudades-circle\n, y la vamos a definir a continuaci\u00f3n de \nciudades\n\ny justo antes de \naeropuertos\n. Dibujaremos un c\u00edrculo cuyo tama\u00f1o ser\u00e1 inversamente proporcional a la\npropiedad \nSCALERANK\n.\n\n\nAdem\u00e1s, las capitales estatales se simbolizar\u00e1n como un c\u00edrculo blanco con un borde grueso, y el resto de\nciudades con un c\u00edrculo gris con borde m\u00e1s fino.\n\n\nUsaremos la misma expresi\u00f3n Match que hemos visto anteriormente, aplicada a un color y a un grueso de l\u00ednea.\n\n\nAdem\u00e1s, aplicaremos una expresi\u00f3n matem\u00e1tica \n[\"-\"]\n, que resta dos valores, de manera que el tama\u00f1o del c\u00edrculo\nser\u00e1 \n10 - SCALERANK\n: \n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n{\n\n    \nid\n:\n \nciudades-circle\n,\n\n    \ntype\n:\n \ncircle\n,\n\n    \nsource\n:\n \nnaturalearth\n,\n\n    \nsource-layer\n:\n \ncities\n,\n\n    \npaint\n:\n \n{\n\n        \ncircle-color\n:\n \n[\n\n            \nmatch\n,\n \n[\nget\n,\n \nADM0CAP\n],\n\n            \n0\n,\n \n#888\n,\n\n            \n#FFF\n\n        \n],\n\n        \ncircle-stroke-width\n:\n \n[\n\n            \nmatch\n,\n \n[\nget\n,\n \nADM0CAP\n],\n\n            \n0\n,\n \n1\n,\n\n            \n2\n\n        \n],\n\n        \ncircle-radius\n:\n \n[\n-\n,\n \n10\n,\n \n[\nget\n,\n \nSCALERANK\n]]\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nUso de fuentes de datos externas\n\n\nPor \u00faltimo, vamos a a\u00f1adir un fondo raster al mapa, procedente de otro tileserver.\n\n\n\n\nA\u00f1adiremos un nuevo \nsource\n de tipo \nraster\n, a continuaci\u00f3n del source \nnaturalearth\n:\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n{\n\n    \n...\n\n    \nrelief\n:\n \n{\n\n        \ntype\n:\n \nraster\n,\n\n        \ntiles\n:\n \n[\nhttp://naturalearthtiles.lukasmartinelli.ch/tiles/natural_earth_2_shaded_relief.raster/{z}/{x}/{y}.png\n],\n\n        \ntileSize\n:\n \n256\n,\n\n        \nmaxzoom\n:\n \n6\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\n\nBorraremos el \nlayer\n llamado \ntierra\n.\n\n\nA\u00f1adiremos un nuevo \nlayer\n justo despu\u00e9s del \nfondo\n que se llamar\u00e1 \nterreno\n:\n\n\n\n\n1\n2\n3\n4\n5\n{\n\n  \nid\n:\n \nterreno\n,\n\n  \ntype\n:\n \nraster\n,\n\n  \nsource\n:\n \nrelief\n\n\n}\n\n\n\n\n\n\n\nEl resultado final de aplicar todos estos estilos tendr\u00e1 este aspecto:\n\n\n\n\nEjercicio extra: uso de una fuente con iconos para simbolizar un punto\n\n\nSi se ha hecho el ejercicio extra del apartado anterior, en el que cre\u00e1bamos una fuente\na partir de una colecci\u00f3n de iconos, ahora veremos c\u00f3mo utilizarla en el Layer de\naeropuertos:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n{\n\n  \nid\n:\n \naeropuertos\n,\n\n  \ntype\n:\n \nsymbol\n,\n\n  \nsource\n:\n \nnaturalearth\n,\n\n  \nsource-layer\n:\n \nairports\n,\n\n  \nlayout\n:\n \n{\n\n    \nsymbol-placement\n:\n \npoint\n,\n\n\n    \nicon-image\n:\n \n,\n\n\n    \ntext-font\n:\n \n[\nGeostart Regular\n],\n\n\n    \ntext-size\n:\n \n25\n,\n\n\n    \ntext-field\n:\n \n,\n\n\n  \n},\n\n  \npaint\n:\n \n{\n\n    \ntext-color\n:\n \n#fabada\n,\n\n    \ntext-halo-color\n:\n \n#888\n,\n\n    \ntext-halo-width\n:\n \n2\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nEn las l\u00edneas destacadas se observa c\u00f3mo no se usa una \nicon-image\n, sino una etiqueta de texto (\ntext-font\n, \ntext-size\n\ny \ntext-field\n). En \ntext-field\n se indica una coma \n\",\"\n, que corresponde al icono que queremos mostrar.\nAl tratarse de una fuente, podemos indicar el tama\u00f1o que queramos sin miedo a obtener una imagen pixelada,\ny aplicar otras propiedades como escoger color, halo, etc.\n\n\nComo resultado del estilo indicado se simbolizar\u00edan los aeropuertos as\u00ed:", 
            "title": "6. C\u00f3mo simbolizarlas"
        }, 
        {
            "location": "/6_estilos/#como-simbolizar-teselas-vectoriales", 
            "text": "", 
            "title": "C\u00f3mo simbolizar teselas vectoriales"
        }, 
        {
            "location": "/6_estilos/#maputnik", 
            "text": "Es un editor visual gratuito y abierto para estilos Mapbox GL dirigidos tanto a desarrolladores\ncomo a dise\u00f1adores de mapas.  Se puede utilizar en l\u00ednea en  Maputnik editor  o se puede\nhacer una instalaci\u00f3n local.", 
            "title": "Maputnik"
        }, 
        {
            "location": "/6_estilos/#instalacion", 
            "text": "Se puede descargar la \u00faltima versi\u00f3n de la  p\u00e1gina de releases .\nEn nuestro caso, la tenemos ya descargada en  ~/Desktop/taller-vt/maputnik .  Para arrancar la versi\u00f3n local:  1\n2 cd  ~/Desktop/taller-vt/maputnik\nlive-server --port = 8082    Abrir Maputnik en  http://localhost:8082", 
            "title": "Instalaci\u00f3n"
        }, 
        {
            "location": "/6_estilos/#comenzar-un-estilo-nuevo", 
            "text": "En la barra de men\u00fa seleccionamos la opci\u00f3n  Open .\nDel apartado  Gallery Styles , seleccionamos  Empty Style .", 
            "title": "Comenzar un estilo nuevo"
        }, 
        {
            "location": "/6_estilos/#agregar-un-origen-de-datos-source", 
            "text": "En la barra de men\u00fa seleccionamos la opci\u00f3n  Source .\nEn la parte inferior del di\u00e1logo est\u00e1 la secci\u00f3n:  Add New Source .    Como  Source ID  ponemos  naturalearth .  Como  Source Type  seleccionamos  Vector (TileJSON URL) .  Como  TileJSON URL  seleccionamos  http://localhost:8081/data/natural_earth.json   Tambi\u00e9n se podr\u00eda usar como  Source Type  un  Vector (XYZ URL) , en cuyo caso tambi\u00e9n hay que\nindicar el rango de zooms en que los datos son v\u00e1lidos.", 
            "title": "Agregar un origen de datos (Source)"
        }, 
        {
            "location": "/6_estilos/#agregar-sprite-y-glyphs", 
            "text": "En la barra de men\u00fa seleccionamos  Style Settings :    Name : Nombre del estilo. En nuestro caso pondremos  Natural Earth .  Sprite URL : Usaremos el sprite de uno de los estilos que tenemos publicados en tileserver  http://localhost:8081/styles/osm-bright/sprite  Glyphs URL : Accederemos a las tipograf\u00edas publicadas en nuestro Tileserver  http://localhost:8081/fonts/{fontstack}/{range}.pbf", 
            "title": "Agregar sprite y glyphs"
        }, 
        {
            "location": "/6_estilos/#simbolizacion-basica", 
            "text": "Presionamos el bot\u00f3n de  Add Layer :", 
            "title": "Simbolizaci\u00f3n b\u00e1sica"
        }, 
        {
            "location": "/6_estilos/#fondo", 
            "text": "A\u00f1adimos una primera capa de fondo:   ID : identificador \u00fanico de la capa. Pondremos  fondo .  Type : tipo de capa. Seleccionar la opci\u00f3n de  Background .   Seleccionamos el color en  Paint properties  =   Color : \"#50A8E7\".  El fondo del mapa pasa a un gris claro.", 
            "title": "Fondo"
        }, 
        {
            "location": "/6_estilos/#oceanos", 
            "text": "A\u00f1adimos ahora los oc\u00e9anos:    ID : identificador \u00fanico de la capa. Pondremos  oceanos .  Type : tipo de capa. Seleccionar la opci\u00f3n de  Fill  ya que la capa es de tipo pol\u00edgono.  Source : identificador del origen de datos. En nuestro caso pondremos  naturalearth .  Source Layer : identificador de la capa dentro del origen de datos. Pondremos  ocean .   Aparecer\u00e1n los oc\u00e9anos de color negro.  Simbolizamos la capa seleccionando un color RGB en  Paint properties  =   Color : \"#50A8E7\".  En el apartado inferior del panel de propiedades de la capa, vamos viendo la definici\u00f3n tal\ncomo se guardar\u00e1 en el fichero json de estilo:  1\n2\n3\n4\n5\n6\n7\n8\n9 { \n   id :   oceanos , \n   type :   fill , \n   source :   naturalearth , \n   source-layer :   ocean , \n   paint :   { \n     fill-color :   #50A8E7 \n   }  }    Maputnik no es m\u00e1s que un asistente gr\u00e1fico para generar el fichero  style.json .", 
            "title": "Oc\u00e9anos"
        }, 
        {
            "location": "/6_estilos/#resto-de-capas-basicas", 
            "text": "El resto de capas se puede simbolizar procediendo de la misma manera:      id  type  source-layer  color  otras propiedades \"paint\"      fondo  Background  --  #F8F4F0  --    oceanos  Fill  ocean  #A0C8F0  --    tierra  Fill  land  #E6C7C7  --    costa  Line  coastline  #4793E8  --    rios  Line  rivers  #4793E8  --    lagos  Fill  lakes  #A0C8F0  \"stroke-color\": \"#4793E8\"    ferrocarril  Line  rail  #707070  --    carreteras  Line  roads  #BF5757  --", 
            "title": "Resto de capas b\u00e1sicas"
        }, 
        {
            "location": "/6_estilos/#filtrar-los-datos-a-mostrar-en-una-capa", 
            "text": "Vamos a eliminar las rutas de ferry que se muestran como carreteras.  Hay dos maneras de definir un filtro en un estilo MapboxGL:\n1.  Filters : La forma cl\u00e1sica, que implementa Maputnik:  https://www.mapbox.com/mapbox-gl-js/style-spec/#other-filter \n2.  Decision Expressions : La nueva forma, m\u00e1s potente, pero que Maputnik no implementa:  https://www.mapbox.com/mapbox-gl-js/style-spec/#expressions-decision  En Maputnik, seleccionando la capa  carreteras , apartado  Filter : Presionamos el bot\u00f3n  Add filter .\nLa condici\u00f3n ser\u00e1:  1     featurecla == Road    Comprobar que desaparecen las l\u00edneas de Ferry en el mapa.   Tip  Usa el  Inspect Mode  integrado en Maputnik para explorar los diferentes campos de una capa y sus posibles valores.", 
            "title": "Filtrar los datos a mostrar en una capa"
        }, 
        {
            "location": "/6_estilos/#ejercicio-extra", 
            "text": "Crea una nueva capa \"ferrys\" y aplica el filtro contrario para mostrar s\u00f3lo las rutas de ferry.\nInvestiga la propiedad  Dasharray  para darle un aspecto de l\u00ednea discontinua a las rutas.", 
            "title": "Ejercicio extra"
        }, 
        {
            "location": "/6_estilos/#etiquetar-una-capa", 
            "text": "Agregar la capa de ciudades. Presionar el bot\u00f3n de  Add Layer  y rellenar el formulario con\nla siguiente informaci\u00f3n:   ID :  ciudades  Type :  Symbol , utilizado para mostrar entidades puntuales (iconos y etiquetas)  Source :  naturalearth  Source Layer :  cities     En el apartado  Text layout properties :   En la propiedad  Field  escribir  {NAME}  (el nombre del campo a mostrar, entre llaves).  En la propiedad  Font , escribir  Comic Sans , tipograf\u00eda que hemos generado y publicado en el apartado anterior (nota: el taller sobre c\u00f3mo evitar hacer mapas feos es esta tarde).     Estilizar las etiquetas. En el apartado de  Text paint properties :\n Para los textos podemos definir un Halo para que el teto destaque mejor en nuestro mapa.", 
            "title": "Etiquetar una capa"
        }, 
        {
            "location": "/6_estilos/#utilizar-un-icono-para-simbolizar-nuestra-capa", 
            "text": "Agregar la capa de aeropuertos. Presionar el bot\u00f3n de  Add Layer  y rellenar el formulario con\nla siguiente informaci\u00f3n:   ID :  aeropuertos  Type :  Symbol , utilizado para mostrar entidades puntuales (iconos y etiquetas)  Source :  naturalearth  Source Layer :  airports     En el apartado de  Icon layout properties :   En la propiedad  Image , escribir  airport_11 . Este nombre debe coincidir con alguna imagen definida en el sprite.     Comprobar que aparecen los aeropuertos en el mapa.     Tip  Estos son los iconos del sprite del estilo ( osm-bright ) que estamos utilizando: https://github.com/openmaptiles/osm-bright-gl-style/tree/master/icons", 
            "title": "Utilizar un icono para simbolizar nuestra capa"
        }, 
        {
            "location": "/6_estilos/#exportar-el-estilo-creado", 
            "text": "Seleccionar la opci\u00f3n  Export , y luego el boton de  Download  para descargar el estilo en nuestro ordenador.\nDescargamos el archivo, lo renombramos a  style.json  y lo movemos a la carpeta  tileserver/styles/natural-earth/ ,\ndonde ya hab\u00edamos copiado los sprites generados en el apartado anterior.  Habr\u00e1 que editar el fichero de configuraci\u00f3n de tileserver  tileserver/config.json  para a\u00f1adir el estilo:   1\n2\n3\n4\n5\n6\n7 { \n   styles :   { \n     natural-earth :   { \n       style :   natural-earth/style.json \n     } \n   }  }    Reiniciar tileserver y comprobar que ofrece el nuevo estilo de visualizaci\u00f3n.", 
            "title": "Exportar el estilo creado"
        }, 
        {
            "location": "/6_estilos/#edicion-manual-del-estilo", 
            "text": "Vamos a dejar Maputnik a un lado y vamos a editar el estilo json a mano.", 
            "title": "Edici\u00f3n manual del estilo"
        }, 
        {
            "location": "/6_estilos/#crear-un-visor-para-el-nuevo-estilo", 
            "text": "Lo primero ser\u00e1 crear un visor para los datos y estilo de Natural Earth partiendo del visor de Barcelona.\nTambi\u00e9n usaremos una copia local del estilo porque ser\u00e1 m\u00e1s f\u00e1cil ir viendo los cambios. Cada vez que guardemos en disco una\nmodificaci\u00f3n del fichero de estilo, podremos recargar directamente la p\u00e1gina en el navegador para reflejar los cambios.   Copiar el archivo  visor/barcelona.html  en  visor/naturalearth.html  Adem\u00e1s, hacer una copia de  tileserver/styles/natural-earth/style.json  en  visor/natural-earth-style.json .   Editaremos  visor/naturalearth.html  y en la parte de  script  dejaremos s\u00f3lo este c\u00f3digo:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 var   map   =   new   mapboxgl . Map ({ \n     container :   map , \n     style :   natural-earth-style.json , \n     center :   [ 1.5 ,   41 ], \n     zoom :   5 , \n     hash :   true  });  map . addControl ( new   mapboxgl . NavigationControl ());  map . addControl ( new   MapboxInspect ());    Abriendo en el navegador  http://127.0.0.1:8080/naturalearth.html  deber\u00eda verse:", 
            "title": "Crear un visor para el nuevo estilo"
        }, 
        {
            "location": "/6_estilos/#estilo-avanzado-basado-en-expresiones", 
            "text": "El estilo basado en datos permite estilizar los datos en funci\u00f3n del valor de sus propiedades.\nPor ejemplo, cambiar el radio de un c\u00edrculo o el color de un pol\u00edgono en funci\u00f3n de un valor\nnum\u00e9rico, o usar l\u00f3gica condicional para crear etiquetas multiling\u00fces.  Las  expresiones de Mapbox GL  se\npueden usar en cualquier propiedad de tipo  layout ,  paint  o  filter  de una  layer .  Gracias a las expresiones, una regla de simbolizaci\u00f3n determinada puede calcularse como el resultado de\nun c\u00e1lculo donde intervienen los valores de una o m\u00e1s propiedades de una  feature . Pueden\nusarse operaciones l\u00f3gicas, matem\u00e1ticas, de generaci\u00f3n de color, interpolaciones, etc.", 
            "title": "Estilo avanzado basado en expresiones"
        }, 
        {
            "location": "/6_estilos/#estilo-basado-en-valores-concretos-de-una-propiedad", 
            "text": "Abrir el fichero  natural-earth-style.json  y localizar el layer con id  carreteras .  Vamos a asignar un color distinto en funci\u00f3n del valor de la propiedad  type .\nPara ello usaremos la expresi\u00f3n  Match ,\nque asigna a cada valor de entrada un valor de salida distinto (en nuestro caso, un color para\ncada tipo de carretera):  1\n2\n3\n4\n5\n6 [ match ,  propiedad ,\n     valorentrada_1 ,  salida_1 ,\n     entrada_2 ,  salida_2 ,\n    ...,\n     salida_por_defecto \n]   Para obtener el valor de la propiedad de una feature se usa la expresi\u00f3n Get:  [\"get\",  nombre_propiedad ] .   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17 { \n     id :   carreteras , \n     type :   line , \n     source :   naturalearth , \n     source-layer :   roads , \n     filter :   [ all ,   [ == ,   featurecla ,   Road ]], \n     paint :   { \n         line-color :   [               match ,   [ get ,   type ],               Major Highway ,       rgba(20, 52, 232, 1) ,               Secondary Highway ,   rgba(206, 32, 79, 1) ,               Road ,                rgba(49, 137, 52, 1) ,               rgba(255, 204, 0, 1)           ], \n         line-width :   2 \n     }  }", 
            "title": "Estilo basado en valores concretos de una propiedad"
        }, 
        {
            "location": "/6_estilos/#estilo-basado-en-el-nivel-del-zoom", 
            "text": "Localizar el layer con id  ciudades .  Vamos a cambiar el tama\u00f1o del texto seg\u00fan el nivel de zoom del mapa, y de la propiedad  SCALERANK  del dato.  Usaremos la expresi\u00f3n  Case , que tiene\nesta forma:  1\n2\n3\n4\n5\n6 [ case ,\n     condicion_1 ,  salida_1 ,\n     condicion_2 ,  salida_2 ,\n    ...,\n     salida_por_defecto \n]   En nuestro caso la usaremos para decir cosas como:   Si \"SCALERANK\" es menor que 2, aplica un tama\u00f1o de letra 20,  Si \"SCALERANK\" est\u00e1 entre 3 y 5, aplica un tama\u00f1o de letra 14,  En cualquier otro caso, aplica un tama\u00f1o de letra 10   Que quedar\u00eda expresado as\u00ed:  1\n2\n3\n4\n5\n6 [ \n   case , \n   [ = ,   [ number ,[ get ,   SCALERANK ]],   2 ],   20 , \n   [ = ,   [ number ,[ get ,   SCALERANK ]],   5 ],   14 , \n   10  ]    El operador  \"number\"  se usa para convertir el valor  SCALERANK  a un tipo num\u00e9rico.  Y la combinaremos con la expresi\u00f3n  Step , que tiene\nesta forma:  1\n2\n3\n4\n5\n6 [ step ,\n     entrada ,  salida_inicial ,\n     umbral_1 ,  salida_1 ,\n     umbral_2 ,  salida_2 ,\n    ...\n]   En nuestro caso la podemos usar para decir cosas como:   Usa un tama\u00f1o de letra 18 para zooms por debajo de 5.  Usa un tama\u00f1o de letra 20 entre el zoom 5 y 8.  Usa un tama\u00f1o de letra 24 para zooms mayores que 8.   Que quedar\u00eda:  1\n2\n3\n4\n5 [ step , \n     [ zoom ],   18 , \n     5 ,   20 , \n     8 ,   24  ]    Obviamente podemos combinar ambas expresiones, de forma que la salida para cada nivel de zoom no sea un tama\u00f1o de\n letra concreto, sino que dependa de \"SCALERANK\". Y nos queda el siguiente monstruo para el Layer:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34 { \n     id :   ciudades , \n     type :   symbol , \n     source :   naturalearth , \n     source-layer :   cities , \n     layout :   { \n         text-field :   {NAME} , \n         text-anchor :   bottom , \n         text-offset :   [ 0 ,   -1 ], \n         text-size :   [ \n             step ,   [ zoom ], \n             [ \n               case , \n               [ ,   [ number ,   [ get ,   SCALERANK ]],   3 ],   18 , \n               0 \n             ], \n             5 ,   [ case , \n                   [ = ,   [ number ,[ get ,   SCALERANK ]],   2 ],   20 , \n                   [ = ,   [ number ,[ get ,   SCALERANK ]],   5 ],   14 , \n                   10 \n                ], \n             8 ,   [ case , \n                   [ = ,   [ number ,[ get ,   SCALERANK ]],   2 ],   24 , \n                   [ = ,   [ number ,[ get ,   SCALERANK ]],   5 ],   18 , \n                   14 \n                ] \n         ] \n     }, \n     paint :   { \n         text-halo-color :   rgba(253, 253, 253, 1) , \n         text-color :   rgba(16, 16, 16, 1) , \n         text-halo-width :   1.5 \n     }  }    Como se puede observar, las expresiones son tan potentes como dif\u00edciles de escribir bien a la primera.", 
            "title": "Estilo basado en el nivel del zoom"
        }, 
        {
            "location": "/6_estilos/#estilo-basado-en-una-propiedad", 
            "text": "Vamos a crear un nuevo  layer  llamado  ciudades-circle , y la vamos a definir a continuaci\u00f3n de  ciudades \ny justo antes de  aeropuertos . Dibujaremos un c\u00edrculo cuyo tama\u00f1o ser\u00e1 inversamente proporcional a la\npropiedad  SCALERANK .  Adem\u00e1s, las capitales estatales se simbolizar\u00e1n como un c\u00edrculo blanco con un borde grueso, y el resto de\nciudades con un c\u00edrculo gris con borde m\u00e1s fino.  Usaremos la misma expresi\u00f3n Match que hemos visto anteriormente, aplicada a un color y a un grueso de l\u00ednea.  Adem\u00e1s, aplicaremos una expresi\u00f3n matem\u00e1tica  [\"-\"] , que resta dos valores, de manera que el tama\u00f1o del c\u00edrculo\nser\u00e1  10 - SCALERANK :    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19 { \n     id :   ciudades-circle , \n     type :   circle , \n     source :   naturalearth , \n     source-layer :   cities , \n     paint :   { \n         circle-color :   [ \n             match ,   [ get ,   ADM0CAP ], \n             0 ,   #888 , \n             #FFF \n         ], \n         circle-stroke-width :   [ \n             match ,   [ get ,   ADM0CAP ], \n             0 ,   1 , \n             2 \n         ], \n         circle-radius :   [ - ,   10 ,   [ get ,   SCALERANK ]] \n     }  }", 
            "title": "Estilo basado en una propiedad"
        }, 
        {
            "location": "/6_estilos/#uso-de-fuentes-de-datos-externas", 
            "text": "Por \u00faltimo, vamos a a\u00f1adir un fondo raster al mapa, procedente de otro tileserver.   A\u00f1adiremos un nuevo  source  de tipo  raster , a continuaci\u00f3n del source  naturalearth :   1\n2\n3\n4\n5\n6\n7\n8\n9 { \n     ... \n     relief :   { \n         type :   raster , \n         tiles :   [ http://naturalearthtiles.lukasmartinelli.ch/tiles/natural_earth_2_shaded_relief.raster/{z}/{x}/{y}.png ], \n         tileSize :   256 , \n         maxzoom :   6 \n     }  }     Borraremos el  layer  llamado  tierra .  A\u00f1adiremos un nuevo  layer  justo despu\u00e9s del  fondo  que se llamar\u00e1  terreno :   1\n2\n3\n4\n5 { \n   id :   terreno , \n   type :   raster , \n   source :   relief  }    El resultado final de aplicar todos estos estilos tendr\u00e1 este aspecto:", 
            "title": "Uso de fuentes de datos externas"
        }, 
        {
            "location": "/6_estilos/#ejercicio-extra-uso-de-una-fuente-con-iconos-para-simbolizar-un-punto", 
            "text": "Si se ha hecho el ejercicio extra del apartado anterior, en el que cre\u00e1bamos una fuente\na partir de una colecci\u00f3n de iconos, ahora veremos c\u00f3mo utilizarla en el Layer de\naeropuertos:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18 { \n   id :   aeropuertos , \n   type :   symbol , \n   source :   naturalearth , \n   source-layer :   airports , \n   layout :   { \n     symbol-placement :   point ,       icon-image :   ,       text-font :   [ Geostart Regular ],       text-size :   25 ,       text-field :   ,     }, \n   paint :   { \n     text-color :   #fabada , \n     text-halo-color :   #888 , \n     text-halo-width :   2 \n   }  }    En las l\u00edneas destacadas se observa c\u00f3mo no se usa una  icon-image , sino una etiqueta de texto ( text-font ,  text-size \ny  text-field ). En  text-field  se indica una coma  \",\" , que corresponde al icono que queremos mostrar.\nAl tratarse de una fuente, podemos indicar el tama\u00f1o que queramos sin miedo a obtener una imagen pixelada,\ny aplicar otras propiedades como escoger color, halo, etc.  Como resultado del estilo indicado se simbolizar\u00edan los aeropuertos as\u00ed:", 
            "title": "Ejercicio extra: uso de una fuente con iconos para simbolizar un punto"
        }, 
        {
            "location": "/7_servidor_dinamico/", 
            "text": "C\u00f3mo servir datos din\u00e1micos\n\n\nPartiremos de unos datos con los distritos, barrios y secciones censales de Barcelona.\nLos datos est\u00e1n en \ndatos/bcn_geodata.sql\n.\n\n\n\n\nNote\n\n\nEl origen de los datos es Ajuntament de Barcelona CC-by (\nhttp://w20.bcn.cat/cartobcn/\n).\nMart\u00edn Gonz\u00e1lez los convirti\u00f3 a GeoJSON (\nhttps://github.com/martgnz/bcn-geodata\n).\nPara el taller los hemos convertido de GeoJSON a PostGIS.\n\n\n\n\nCargarlos en PostGIS:\n\n\n1\npsql \n datos/bcn_geodata.sql\n\n\n\n\n\n\nSe crear\u00e1 una BDD \nbcn_geodata\n con las tablas \nbarrios\n, \ndistritos\n y \nseccion_censal\n.\nSe puede acceder a esta BDD con el usuario \nuser\n, password \nuser\n.\n\n\nUna vez con los datos cargados en PostGIS, usaremos \ntegola\n para levantar un servidor de teselas\nvectoriales partir de una BDD PostGIS.\n\n\nInstalando Tegola\n\n\nTegola consiste en un solo fichero ejecutable. La instalaci\u00f3n consiste en descargarse un zip, descomprimirlo, y copiar\nel fichero ejecutable resultante en una ruta localizable:\n\n\n1\n2\n3\nwget https://github.com/go-spatial/tegola/releases/download/v0.6.3/tegola_linux_amd64.zip\nunzip tegola_linux_amd64.zip\nsudo mv tegola_linux_amd64 /usr/local/bin/tegola\n\n\n\n\n\n\nComprobar que puede ejecutarse tegola correctamente, y borrar el zip:\n\n\n1\n2\ntegola -h \n# comprobar instalacion\n\nrm tegola_linux_amd64.zip\n\n\n\n\n\n\nConfigurando Tegola\n\n\nTegola necesita de un \nfichero de configuraci\u00f3n en formato toml\n para funcionar.\nEn \u00e9l estableceremos los par\u00e1metros de conexi\u00f3n con la BDD y las caracter\u00edsticas de las capas que queremos servir.\n\n\nCreemos pues un directorio llamado \ntegola\n, y en \u00e9l, un fichero llamado \nconfig.toml\n.\n\n\nLo primero es definir una secci\u00f3n con el puerto que usaremos para levantar el servicio: \n\n\n1\n2\n[webserver]\n\n\nport\n \n=\n \n:8083\n\n\n\n\n\n\n\nA continuaci\u00f3n definimos la conexi\u00f3n con la BDD en una secci\u00f3n \nproviders\n. Dentro del provider, definimos las capas de\ndatos que queremos obtener de la BDD. En nuestro caso son muy sencillas:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n[[providers]]\n\n\nname\n \n=\n \npostgis\n\n\ntype\n \n=\n \npostgis\n\n\nhost\n \n=\n \nlocalhost\n\n\nport\n \n=\n \n5432\n\n\ndatabase\n \n=\n \nbcn_geodata\n\n\nuser\n \n=\n \nuser\n\n\npassword\n \n=\n \nuser\n\n\n    \n[[providers.layers]]\n\n    \nname\n \n=\n \ndistritos\n\n\n    tablename = \ndistritos\n\n\n    \n[[providers.layers]]\n\n    \nname\n \n=\n \nbarrios\n\n\n    tablename = \nbarrios\n\n\n    \n[[providers.layers]]\n\n    \nname\n \n=\n \nseccion_censal\n\n\n    tablename = \nseccion_censal\n\n\n\n\n\n\n\nEn estas \nproviders.layers\n tambi\u00e9n se podr\u00edan seleccionar qu\u00e9 columnas queremos obtener, o incluso indicar una consulta SQL para\ngenerar la capa, haciendo JOIN de varias tablas, aplicando operaciones espaciales, etc. En nuestro caso, servimos las\ntablas tal cual.\n\n\nFinalmente, creamos una secci\u00f3n \nmaps\n, que consiste en un nombre, y una serie de capas de informaci\u00f3n:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n[[maps]]\n\n\nname\n \n=\n \nbcn_geodata\n\n\nattribution\n \n=\n \nCC-by Ajuntament de Barcelona\n\n\ncenter\n \n=\n \n[2.175, 41.39, 13.0]\n\n\nbounds\n \n=\n \n[1.898, 41.246, 2.312, 41.533]\n\n\n    \n[[maps.layers]]\n\n    \nprovider_layer\n \n=\n \npostgis.seccion_censal\n\n\n    dont_simplify = true\n\n\n    min_zoom = 11\n\n\n    max_zoom = 16\n\n\n    \n[[maps.layers]]\n\n    \nprovider_layer\n \n=\n \npostgis.barrios\n\n\n    dont_simplify = true\n\n\n    min_zoom = 10\n\n\n    max_zoom = 16\n\n\n    \n[[maps.layers]]\n\n    \nprovider_layer\n \n=\n \npostgis.distritos\n\n\n    dont_simplify = true\n\n\n    min_zoom = 0\n\n\n    max_zoom = 16\n\n\n\n\n\n\n\nEn estas \nmaps.layers\n se indican par\u00e1metros para la generaci\u00f3n de las VT, como el rango de niveles de zoom en las que\nser\u00e1n visibles, si se simplificar\u00e1 o no la geometr\u00eda.\n\n\nEn la configuraci\u00f3n tambi\u00e9n existe la posibilidad de activar una cach\u00e9 en disco, en s3 o en redis, as\u00ed como comandos para\ninvalidar partes de la cach\u00e9. En nuestro caso, no hemos usado cach\u00e9.\n\n\nArrancando tegola\n\n\nArrancamos el servicio desde el directorio donde hayamos guardato \nconfig.toml\n:\n\n\n1\n2\ncd\n tegola\ntegola serve\n\n\n\n\n\n\nY abrimos \nhttp://localhost:8083\n :\n\n\n\n\nActivando \"Inspect Features\" podremos ver los atributos de cada elemento.\n\n\nLas teselas est\u00e1n disponibles en: \nhttp://localhost:8083/maps/bcn_geodata/{z}/{x}/{y}.pbf\n\n\nIncorporando los datos en el visor de Barcelona\n\n\nA\u00f1adiremos el siguiente c\u00f3digo javascript a \nbarcelona.html\n para incorporar el nuevo origen de datos, y una simbolizaci\u00f3n b\u00e1sica para mostrar las secciones censales:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n    \nmap\n.\non\n(\nload\n,\n \nfunction\n()\n \n{\n\n        \nmap\n.\naddSource\n(\nbcn_geodata\n,\n \n{\n\n            \ntype\n:\n \nvector\n,\n\n            \ntiles\n:\n \n[\nhttp://localhost:8083/maps/bcn_geodata/{z}/{x}/{y}.pbf\n]\n\n        \n});\n\n\n        \nmap\n.\naddLayer\n({\n\n            \nid\n:\n \nseccion_censal\n,\n\n            \nsource\n:\n \nbcn_geodata\n,\n\n            \nsource-layer\n:\n \nseccion_censal\n,\n\n            \ntype\n:\n \nfill\n,\n\n            \npaint\n:\n \n{\n\n                \nfill-opacity\n:\n \n0.6\n,\n\n                \nfill-color\n:\n \n#fcc\n,\n\n                \nfill-outline-color\n:\n \n#000\n\n            \n}\n\n        \n});\n\n    \n});\n\n\n\n\n\n\n\n\n\nTem\u00e1tico avanzado\n\n\nExpresiones matem\u00e1ticas\n\n\nEn las tablas tenemos los campos de poblaci\u00f3n divididos en hombres (\nhomes\n) y mujeres (\ndones\n), as\u00ed como el \u00e1rea en\nm\u00b2 de cada secci\u00f3n. Con estos datos, podemos calcular la densidad de poblaci\u00f3n en habitantes/km\u00b2 seg\u00fan la f\u00f3rmula:\n\n\n1\ndensidad = (homes+dones)/(area/1000000)\n\n\n\n\n\n\nEl estilo de mapbox-gl permite expresar \noperaciones matem\u00e1ticas usando expresiones\n,\nde la forma:\n\n\n\n\n[\"+\", [\"get\", \"homes\"], [\"get\", \"dones\"]]\n para sumar la poblaci\u00f3n de hombres y de mujeres\n\n\n[\"/\", [\"get\", \"area\"], 1000000]\n para pasar el \u00e1rea de m\u00b2 a km\u00b2\n\n\n\n\nY, combinando ambas, obtenemos la densidad de poblaci\u00f3n en habitantes/km\u00b2:\n\n\n1\n2\n3\n4\n[\n/\n,\n\n    \n[\n+\n,\n \n[\nget\n,\n \nhomes\n],\n \n[\nget\n,\n \ndones\n]],\n\n    \n[\n/\n,\n \n[\nget\n,\n \narea\n],\n \n1000000\n]\n\n\n]\n\n\n\n\n\n\n\nRampas de color\n\n\nAs\u00ed mismo, las expresiones de los estilos de mapbox-gl nos permiten \naplicar un n\u00famero discreto de valores de salida a\nrangos de entrada\n.\nLas definiciones del manual sin un ejemplo concreto son algo dif\u00edciles de leer:\n\n\n1\n2\n3\n4\n5\n6\n[\nstep\n,\n\n    \ninput:\n \nnumber\n,\n\n    \nstop_output_\n0\n:\n \nOutputType\n,\n\n    \nstop_input_\n1\n:\n \nnumber\n,\n \nstop_output_\n1\n:\n \nOutputType\n,\n\n    \nstop_input_n:\n \nnumber\n,\n \nstop_output_n:\n \nOutputType\n,\n \n...\n\n\n]\n:\n \nOutputType\n  \n\n\n\n\n\n\nPero supongamos que queremos aplicar esta expresi\u00f3n para asignar tres colores en funci\u00f3n de rangos de densidad (\n 10.000 hab/km\u00b2\n,\n\nde 10.000 a 25.000 hab/km\u00b2\n, y \n 25.000 hab/km\u00b2\n), la expresi\u00f3n ser\u00eda:\n\n\n1\n2\n3\n4\n5\n6\n[\nstep\n,\n\n    \n[\nget\n,\n \ndensidad\n],\n\n    \nColor_1\n,\n\n    \n10000\n,\n \nColor_2\n,\n\n    \n25000\n,\n \nColor_3\n\n\n]\n\n\n\n\n\n\n\nM\u00e1s sencillo de lo que parec\u00eda.\n\n\nCombinando ambas expresiones\n\n\nPodemos combinar ambas expresiones: \"calcula la densidad y luego asigna un color en funci\u00f3n de su valor\"\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n[\nstep\n,\n\n    \n[\n/\n,\n\n        \n[\n+\n,\n \n[\nget\n,\n \nhomes\n],\n \n[\nget\n,\n \ndones\n]],\n\n        \n[\n/\n,\n \n[\nget\n,\n \narea\n],\n \n1000000\n]\n\n    \n],\n\n    \n#3d5941\n,\n\n    \n17703\n,\n \n#778868\n,\n\n    \n29678\n,\n \n#b5b991\n,\n\n    \n37617\n,\n \n#f6edbd\n,\n\n    \n46016\n,\n \n#edbb8a\n,\n\n    \n54401\n,\n \n#de8a5a\n,\n\n    \n66570\n,\n \n#ca562c\n\n\n]\n\n\n\n\n\n\n\n\n\nTip\n\n\nLos valores de corte para los diferentes colore se han obtenido calculando los cuantiles con PostgreSQL:\n\n\n1\n2\n3\n4\n5\n6\n7\nSELECT\n\n\nntile\n,\n\n\nCAST\n(\nmin\n(\ndensitat\n)\n \nAS\n \nINTEGER\n)\n  \nAS\n \nminAmount\n,\n\n\nCAST\n(\nmax\n(\ndensitat\n)\n \nAS\n \nINTEGER\n)\n  \nAS\n \nmaxAmount\n\n\nFROM\n \n(\nSELECT\n \n(\nhomes\n+\ndones\n)\n/\n(\narea\n/\n1000000\n)\n \nas\n \ndensitat\n,\n \nntile\n(\n7\n)\n \nOVER\n \n(\nORDER\n \nBY\n \n(\nhomes\n+\ndones\n)\n/\n(\narea\n/\n1000000\n))\n \nAS\n \nntile\n \nFROM\n \nseccion_censal\n)\n \nx\n\n\nGROUP\n \nBY\n \nntile\n\n\nORDER\n \nBY\n \nntile\n;\n\n\n\n\n\n\n\nY la rampa de color y sus valores RGB de cada color se han obtenido de \ncarto-colors\n,\nque a su vez est\u00e1n inspirados en ColorBrewer. \n\n\n\n\nAplicada a la propiedad \nfill-color\n del estilo:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n    \nmap\n.\naddLayer\n({\n\n        \nid\n:\n \nseccion_censal\n,\n\n        \nsource\n:\n \nbcn_geodata\n,\n\n        \nsource-layer\n:\n \nseccion_censal\n,\n\n        \ntype\n:\n \nfill\n,\n\n        \npaint\n:\n \n{\n\n            \nfill-opacity\n:\n \n0.75\n,\n\n            \nfill-color\n:\n \n[\nstep\n,\n\n                \n[\n/\n,\n\n                    \n[\n+\n,\n \n[\nget\n,\n \nhomes\n],\n \n[\nget\n,\n \ndones\n]],\n\n                    \n[\n/\n,\n \n[\nget\n,\n \narea\n],\n \n1000000\n]\n\n                \n],\n\n                \n#3d5941\n,\n\n                \n17703\n,\n \n#778868\n,\n\n                \n29678\n,\n \n#b5b991\n,\n\n                \n37617\n,\n \n#f6edbd\n,\n\n                \n46016\n,\n \n#edbb8a\n,\n\n                \n54401\n,\n \n#de8a5a\n,\n\n                \n66570\n,\n \n#ca562c\n\n            \n],\n\n            \nfill-outline-color\n:\n \n#000\n\n        \n}\n\n    \n});\n\n\n\n\n\n\n\nObtendremos:\n\n\n\n\nEjercicio extra: A\u00f1adir extrusi\u00f3n 3D\n\n\nAplicar una extrusi\u00f3n a cada secci\u00f3n censal de altura proporcional a su densidad de poblaci\u00f3n:", 
            "title": "7. C\u00f3mo servir datos din\u00e1micos"
        }, 
        {
            "location": "/7_servidor_dinamico/#como-servir-datos-dinamicos", 
            "text": "Partiremos de unos datos con los distritos, barrios y secciones censales de Barcelona.\nLos datos est\u00e1n en  datos/bcn_geodata.sql .   Note  El origen de los datos es Ajuntament de Barcelona CC-by ( http://w20.bcn.cat/cartobcn/ ).\nMart\u00edn Gonz\u00e1lez los convirti\u00f3 a GeoJSON ( https://github.com/martgnz/bcn-geodata ).\nPara el taller los hemos convertido de GeoJSON a PostGIS.   Cargarlos en PostGIS:  1 psql   datos/bcn_geodata.sql   Se crear\u00e1 una BDD  bcn_geodata  con las tablas  barrios ,  distritos  y  seccion_censal .\nSe puede acceder a esta BDD con el usuario  user , password  user .  Una vez con los datos cargados en PostGIS, usaremos  tegola  para levantar un servidor de teselas\nvectoriales partir de una BDD PostGIS.", 
            "title": "C\u00f3mo servir datos din\u00e1micos"
        }, 
        {
            "location": "/7_servidor_dinamico/#instalando-tegola", 
            "text": "Tegola consiste en un solo fichero ejecutable. La instalaci\u00f3n consiste en descargarse un zip, descomprimirlo, y copiar\nel fichero ejecutable resultante en una ruta localizable:  1\n2\n3 wget https://github.com/go-spatial/tegola/releases/download/v0.6.3/tegola_linux_amd64.zip\nunzip tegola_linux_amd64.zip\nsudo mv tegola_linux_amd64 /usr/local/bin/tegola   Comprobar que puede ejecutarse tegola correctamente, y borrar el zip:  1\n2 tegola -h  # comprobar instalacion \nrm tegola_linux_amd64.zip", 
            "title": "Instalando Tegola"
        }, 
        {
            "location": "/7_servidor_dinamico/#configurando-tegola", 
            "text": "Tegola necesita de un  fichero de configuraci\u00f3n en formato toml  para funcionar.\nEn \u00e9l estableceremos los par\u00e1metros de conexi\u00f3n con la BDD y las caracter\u00edsticas de las capas que queremos servir.  Creemos pues un directorio llamado  tegola , y en \u00e9l, un fichero llamado  config.toml .  Lo primero es definir una secci\u00f3n con el puerto que usaremos para levantar el servicio:   1\n2 [webserver]  port   =   :8083    A continuaci\u00f3n definimos la conexi\u00f3n con la BDD en una secci\u00f3n  providers . Dentro del provider, definimos las capas de\ndatos que queremos obtener de la BDD. En nuestro caso son muy sencillas:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20 [[providers]]  name   =   postgis  type   =   postgis  host   =   localhost  port   =   5432  database   =   bcn_geodata  user   =   user  password   =   user \n\n     [[providers.layers]] \n     name   =   distritos      tablename =  distritos \n\n     [[providers.layers]] \n     name   =   barrios      tablename =  barrios \n\n     [[providers.layers]] \n     name   =   seccion_censal      tablename =  seccion_censal    En estas  providers.layers  tambi\u00e9n se podr\u00edan seleccionar qu\u00e9 columnas queremos obtener, o incluso indicar una consulta SQL para\ngenerar la capa, haciendo JOIN de varias tablas, aplicando operaciones espaciales, etc. En nuestro caso, servimos las\ntablas tal cual.  Finalmente, creamos una secci\u00f3n  maps , que consiste en un nombre, y una serie de capas de informaci\u00f3n:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23 [[maps]]  name   =   bcn_geodata  attribution   =   CC-by Ajuntament de Barcelona  center   =   [2.175, 41.39, 13.0]  bounds   =   [1.898, 41.246, 2.312, 41.533] \n\n     [[maps.layers]] \n     provider_layer   =   postgis.seccion_censal      dont_simplify = true      min_zoom = 11      max_zoom = 16 \n\n     [[maps.layers]] \n     provider_layer   =   postgis.barrios      dont_simplify = true      min_zoom = 10      max_zoom = 16 \n\n     [[maps.layers]] \n     provider_layer   =   postgis.distritos      dont_simplify = true      min_zoom = 0      max_zoom = 16    En estas  maps.layers  se indican par\u00e1metros para la generaci\u00f3n de las VT, como el rango de niveles de zoom en las que\nser\u00e1n visibles, si se simplificar\u00e1 o no la geometr\u00eda.  En la configuraci\u00f3n tambi\u00e9n existe la posibilidad de activar una cach\u00e9 en disco, en s3 o en redis, as\u00ed como comandos para\ninvalidar partes de la cach\u00e9. En nuestro caso, no hemos usado cach\u00e9.", 
            "title": "Configurando Tegola"
        }, 
        {
            "location": "/7_servidor_dinamico/#arrancando-tegola", 
            "text": "Arrancamos el servicio desde el directorio donde hayamos guardato  config.toml :  1\n2 cd  tegola\ntegola serve   Y abrimos  http://localhost:8083  :   Activando \"Inspect Features\" podremos ver los atributos de cada elemento.  Las teselas est\u00e1n disponibles en:  http://localhost:8083/maps/bcn_geodata/{z}/{x}/{y}.pbf", 
            "title": "Arrancando tegola"
        }, 
        {
            "location": "/7_servidor_dinamico/#incorporando-los-datos-en-el-visor-de-barcelona", 
            "text": "A\u00f1adiremos el siguiente c\u00f3digo javascript a  barcelona.html  para incorporar el nuevo origen de datos, y una simbolizaci\u00f3n b\u00e1sica para mostrar las secciones censales:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18      map . on ( load ,   function ()   { \n         map . addSource ( bcn_geodata ,   { \n             type :   vector , \n             tiles :   [ http://localhost:8083/maps/bcn_geodata/{z}/{x}/{y}.pbf ] \n         }); \n\n         map . addLayer ({ \n             id :   seccion_censal , \n             source :   bcn_geodata , \n             source-layer :   seccion_censal , \n             type :   fill , \n             paint :   { \n                 fill-opacity :   0.6 , \n                 fill-color :   #fcc , \n                 fill-outline-color :   #000 \n             } \n         }); \n     });", 
            "title": "Incorporando los datos en el visor de Barcelona"
        }, 
        {
            "location": "/7_servidor_dinamico/#tematico-avanzado", 
            "text": "", 
            "title": "Tem\u00e1tico avanzado"
        }, 
        {
            "location": "/7_servidor_dinamico/#expresiones-matematicas", 
            "text": "En las tablas tenemos los campos de poblaci\u00f3n divididos en hombres ( homes ) y mujeres ( dones ), as\u00ed como el \u00e1rea en\nm\u00b2 de cada secci\u00f3n. Con estos datos, podemos calcular la densidad de poblaci\u00f3n en habitantes/km\u00b2 seg\u00fan la f\u00f3rmula:  1 densidad = (homes+dones)/(area/1000000)   El estilo de mapbox-gl permite expresar  operaciones matem\u00e1ticas usando expresiones ,\nde la forma:   [\"+\", [\"get\", \"homes\"], [\"get\", \"dones\"]]  para sumar la poblaci\u00f3n de hombres y de mujeres  [\"/\", [\"get\", \"area\"], 1000000]  para pasar el \u00e1rea de m\u00b2 a km\u00b2   Y, combinando ambas, obtenemos la densidad de poblaci\u00f3n en habitantes/km\u00b2:  1\n2\n3\n4 [ / , \n     [ + ,   [ get ,   homes ],   [ get ,   dones ]], \n     [ / ,   [ get ,   area ],   1000000 ]  ]", 
            "title": "Expresiones matem\u00e1ticas"
        }, 
        {
            "location": "/7_servidor_dinamico/#rampas-de-color", 
            "text": "As\u00ed mismo, las expresiones de los estilos de mapbox-gl nos permiten  aplicar un n\u00famero discreto de valores de salida a\nrangos de entrada .\nLas definiciones del manual sin un ejemplo concreto son algo dif\u00edciles de leer:  1\n2\n3\n4\n5\n6 [ step , \n     input:   number , \n     stop_output_ 0 :   OutputType , \n     stop_input_ 1 :   number ,   stop_output_ 1 :   OutputType , \n     stop_input_n:   number ,   stop_output_n:   OutputType ,   ...  ] :   OutputType      Pero supongamos que queremos aplicar esta expresi\u00f3n para asignar tres colores en funci\u00f3n de rangos de densidad (  10.000 hab/km\u00b2 , de 10.000 a 25.000 hab/km\u00b2 , y   25.000 hab/km\u00b2 ), la expresi\u00f3n ser\u00eda:  1\n2\n3\n4\n5\n6 [ step , \n     [ get ,   densidad ], \n     Color_1 , \n     10000 ,   Color_2 , \n     25000 ,   Color_3  ]    M\u00e1s sencillo de lo que parec\u00eda.", 
            "title": "Rampas de color"
        }, 
        {
            "location": "/7_servidor_dinamico/#combinando-ambas-expresiones", 
            "text": "Podemos combinar ambas expresiones: \"calcula la densidad y luego asigna un color en funci\u00f3n de su valor\"   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13 [ step , \n     [ / , \n         [ + ,   [ get ,   homes ],   [ get ,   dones ]], \n         [ / ,   [ get ,   area ],   1000000 ] \n     ], \n     #3d5941 , \n     17703 ,   #778868 , \n     29678 ,   #b5b991 , \n     37617 ,   #f6edbd , \n     46016 ,   #edbb8a , \n     54401 ,   #de8a5a , \n     66570 ,   #ca562c  ]     Tip  Los valores de corte para los diferentes colore se han obtenido calculando los cuantiles con PostgreSQL:  1\n2\n3\n4\n5\n6\n7 SELECT  ntile ,  CAST ( min ( densitat )   AS   INTEGER )    AS   minAmount ,  CAST ( max ( densitat )   AS   INTEGER )    AS   maxAmount  FROM   ( SELECT   ( homes + dones ) / ( area / 1000000 )   as   densitat ,   ntile ( 7 )   OVER   ( ORDER   BY   ( homes + dones ) / ( area / 1000000 ))   AS   ntile   FROM   seccion_censal )   x  GROUP   BY   ntile  ORDER   BY   ntile ;    Y la rampa de color y sus valores RGB de cada color se han obtenido de  carto-colors ,\nque a su vez est\u00e1n inspirados en ColorBrewer.    Aplicada a la propiedad  fill-color  del estilo:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23      map . addLayer ({ \n         id :   seccion_censal , \n         source :   bcn_geodata , \n         source-layer :   seccion_censal , \n         type :   fill , \n         paint :   { \n             fill-opacity :   0.75 , \n             fill-color :   [ step , \n                 [ / , \n                     [ + ,   [ get ,   homes ],   [ get ,   dones ]], \n                     [ / ,   [ get ,   area ],   1000000 ] \n                 ], \n                 #3d5941 , \n                 17703 ,   #778868 , \n                 29678 ,   #b5b991 , \n                 37617 ,   #f6edbd , \n                 46016 ,   #edbb8a , \n                 54401 ,   #de8a5a , \n                 66570 ,   #ca562c \n             ], \n             fill-outline-color :   #000 \n         } \n     });    Obtendremos:", 
            "title": "Combinando ambas expresiones"
        }, 
        {
            "location": "/7_servidor_dinamico/#ejercicio-extra-anadir-extrusion-3d", 
            "text": "Aplicar una extrusi\u00f3n a cada secci\u00f3n censal de altura proporcional a su densidad de poblaci\u00f3n:", 
            "title": "Ejercicio extra: A\u00f1adir extrusi\u00f3n 3D"
        }
    ]
}